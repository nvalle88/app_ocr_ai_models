@model app_tramites.Models.ModelAi.ProcessCase
@using Markdig

<div class="container-fluid app-container">
    <div class="row g-1 layout-row">
        <!-- LEFT: Tabla de Fuentes / Documentos -->
        <aside class="col-lg-4 left-col" id="colLeft">
            <div class="card card-panel-left rounded-3 h-100">
                <div class="card-header d-flex align-items-center justify-content-between small-header left-header">
                    <div class="d-flex align-items-center gap-2">
                        <i class="fa fa-folder-open me-2"></i>
                        <strong id="leftHeaderTitle">Fuentes</strong>
                    </div>
                    <div class="d-flex align-items-center gap-2">
                        <small class="text-muted" id="leftCount">@((Model.DataFile?.Count() ?? 0))</small>
                    </div>
                </div>

                <div class="card-body p-2 panel-body panel-height d-flex flex-column">
                    <div id="sourcesWrapper" style="display:block; flex:1 1 auto; overflow:auto;">
                        <table id="sourcesTable" class="table table-borderless table-hover mb-0" style="width:100%;">
                            <thead class="d-none"></thead>
                            <tbody>
                                @foreach (var file in Model.DataFile)
                                {
                                    var origName = file.IsFileUri ? file.FileUri : file.FileUri;
                                    var ext = System.IO.Path.GetExtension(origName)?.ToLower().TrimStart('.') ?? "";
                                    var url = file.FileUri;
                                    var type = (ext == "pdf") ? "pdf" : (ext == "jpg" || ext == "jpeg" || ext == "png" || ext == "webp") ? "img" : "other";
                                                <tr class="source-row" data-url="@url" data-type="@type" data-ext="@ext" title="@System.IO.Path.GetFileName(origName)" style="cursor:pointer;">
                                                    <td style="width:56px; padding:.5rem;">
                                                        <div class="thumb-wrap">
                                                @if (ext == "pdf")
                                                {
                                                                            <i class="fa fa-file-pdf fa-lg text-danger"></i>
                                                }
                                                else
                                                {
                                                                            <img src="@url" class="thumb-img" onerror="this.style.display='none';" />
                                                }
                                                        </div>
                                                    </td>
                                                    <td class="align-middle">
                                                        <div class="fw-semibold text-truncate">@System.IO.Path.GetFileName(origName)</div>
                                                        <small class="text-muted">@ext.ToUpper()</small>
                                                    </td>
                                                    <td class="text-end align-middle" style="width:36px;">
                                                        <i class="fa fa-chevron-right text-muted"></i>
                                                    </td>
                                                </tr>
                                }
                            </tbody>
                        </table>
                    </div>

                    <div id="previewWrapper" style="display:none; flex:1 1 auto; overflow:auto;">
                        <div class="d-flex align-items-center justify-content-between mb-2">
                            <div class="fw-semibold" id="previewTitle">Vista previa</div>
                            <div class="d-flex gap-1">
                                <button id="btnBackToList" class="btn btn-sm btn-outline-secondary" title="Volver al listado"><i class="fa fa-arrow-left"></i> Volver</button>
                                <button id="btnOpenInViewer" class="btn btn-sm btn-light" title="Abrir en nueva pestaña"><i class="fa fa-up-right-from-square"></i></button>
                                <button id="btnDownloadPreview" class="btn btn-sm btn-light" title="Descargar"><i class="fa fa-download"></i></button>
                                <button id="btnFlagPreview" class="btn btn-sm btn-outline-warning" title="Marcar"><i class="fa fa-flag"></i></button>
                            </div>
                        </div>

                        <div id="previewContent" style="width:100%; height:100%; min-height:240px; overflow:auto;">
                        </div>
                    </div>

                    <div class="mt-2 d-flex justify-content-between align-items-center small">
                        <div class="text-muted">Mostrar: <span id="shownCount">0</span></div>
                        <div>
                            <button id="btnRefreshSources" class="btn btn-sm btn-outline-secondary" title="Refrescar lista"><i class="fa fa-sync"></i></button>
                        </div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- CENTER: Chat / Resultados -->
        <main class="col-lg-5 center-col" id="colCenter">
            <div class="card card-panel-center rounded-3 h-100">
                <div class="card-header d-flex align-items-center justify-content-between small-header center-header">
                    <div class="d-flex align-items-center gap-2">
                        <i class="fa-solid fa-magnifying-glass fs-5 text-white" style="opacity:.95"></i>
                        <h5 class="mb-0 header-title">Resultados del Caso</h5>
                    </div>

                    <div>
                        <a asp-action="Index" onclick="cargando()" class="btn btn-primary btn-lg d-flex align-items-center gap-2" id="btnBackPage">
                            <i class="fa fa-arrow-left"></i>
                            <span>Volver</span>
                        </a>
                    </div>
                </div>

                <div class="card-body d-flex flex-column panel-body panel-height">
                    <div class="mb-2 text-muted small">
                        <b>NE-@(((Model.CaseCode.ToString() ?? "").Split('-').FirstOrDefault() ?? ""))</b>
                        @if (Model.FinalResponseResults?.Any() == true)
                        {
                            var lastDate = Model.FinalResponseResults.OrderByDescending(r => r.CreatedDate).FirstOrDefault()?.CreatedDate;
                            if (lastDate != null)
                            {
                                                        <span class="mx-2">·</span>
                                                        <span>@lastDate.Value.ToLocalTime().ToString("dd/MM/yyyy, HH:mm")</span>
                                ;
                            }
                        }
                    </div>

                    <!-- RESULT AREA -->
                    <div class="flex-grow-1 result-area mb-2">
                        <div class="result-panel p-3 h-100">
                            @if (!Model.FinalResponseResults.Any())
                            {
                                            <div class="alert alert-warning text-center mb-0">
                                                <i class="fa fa-info-circle me-2"></i>No hay resultados disponibles para este caso.
                                            </div>
                            }
                            else
                            {
                                var allMarkdown = string.Join("\n\n---\n\n",
                                Model.FinalResponseResults.OrderBy(r => r.CreatedDate).Select(r => r.ResponseText ?? ""));
                                var html = RenderMarkdown(allMarkdown);
                                            <div id="chatOutput" data-content='@Html.Raw(html.Replace("\"", "&quot;"))' style="font-size:15px; line-height:1.6; color:#222;"></div>
                            }
                        </div>
                    </div>

                    <!-- Chat input container: quedará fixed sobre footer (NO movido en DOM) -->
                    <div class="chat-input-wrapper" id="chatInputWrapper" aria-hidden="false">
                        <div class="chat-input-inner" id="chatInputInner" role="region" aria-label="Chat input area">
                            <textarea id="chatInput" class="chat-input form-control" rows="2" placeholder="Comienza a escribir... (Enter = enviar, Shift+Enter = nueva línea)"></textarea>

                            <button id="sendChat" class="chat-send-btn" title="Enviar" aria-label="Enviar" type="button" aria-busy="false">
                                <span class="send-icon" aria-hidden="true"><i class="fa-solid fa-paper-plane"></i></span>
                                <span class="spinner-icon visually-hidden" aria-hidden="true"><i class="fa-solid fa-spinner fa-spin"></i></span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- RIGHT: Studio / Acciones -->
        <aside class="col-lg-3 right-col" id="colRight" aria-hidden="false">
            <div class="card card-panel-right rounded-3 h-100">
                <div class="card-header d-flex align-items-center justify-content-between small-header right-header">
                    <div><strong>Studio</strong></div>
                    <small class="text-muted"></small>
                </div>
                <div class="card-body d-flex flex-column panel-body panel-height">
                    <div class="d-grid gap-2 mb-3 grid-tiles">
                        <button id="studioAudio" class="tile btn btn-light text-start">
                            <div class="tile-icon"><i class="fa fa-wave-square"></i></div>
                            <div class="tile-text">Resumen de audio</div>
                        </button>
                        <button id="studioVideo" class="tile btn btn-light text-start">
                            <div class="tile-icon"><i class="fa fa-video"></i></div>
                            <div class="tile-text">Resumen de video</div>
                        </button>
                        <button id="studioMind" class="tile btn btn-light text-start">
                            <div class="tile-icon"><i class="fa fa-sitemap"></i></div>
                            <div class="tile-text">Mapa mental</div>
                        </button>
                        <div class="tile-dropdown">
                            <button class="tile btn btn-light text-start" id="tileInformes" data-bs-toggle="dropdown" aria-expanded="false">
                                <div class="tile-icon"><i class="fa fa-file-invoice"></i></div>
                                <div class="tile-text">Informes</div>
                            </button>
                            <ul class="dropdown-menu">
                                <li><a class="dropdown-item" href="#">Informe breve</a></li>
                                <li><a class="dropdown-item" href="#">Informe detallado</a></li>
                            </ul>
                        </div>
                    </div>

                    <hr class="my-2" />

                    <div class="mt-auto">
                        <small class="text-muted">Actividades recientes</small>
                        <ul class="list-unstyled mt-2 small">
                            <li class="mb-2"><i class="fa fa-microphone me-2 text-secondary"></i> From Aspiring Student ...</li>
                            <li><i class="fa fa-file-lines me-2 text-secondary"></i> Biografía y Persecución ...</li>
                        </ul>
                    </div>
                </div>
            </div>
        </aside>
    </div>
</div>

<!-- FOOTER (real) -->
<footer id="nexusFooter" class="nexus-notice site-footer" role="contentinfo" aria-hidden="false">
    <div class="nexus-inner">
        <strong>Nexus puede cometer errores.</strong> Comprueba la información importante antes de tomar decisiones.
    </div>
</footer>

@section Scripts {
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

        <script>
        (function () {
            // tokens
            let __pdfRenderToken = 0;
            let __typeToken = 0;
            let __thinkingToken = 0;
            let __currentThinking = null;

            function q(sel) { return document.querySelector(sel); }
            function qa(sel) { return Array.from(document.querySelectorAll(sel)); }

            // set spinner vs icon without replacing innerHTML (evita reflow)
            function setBtnLoading(on) {
                const btn = q('#sendChat'); if (!btn) return;
                const sendIcon = btn.querySelector('.send-icon');
                const spinner = btn.querySelector('.spinner-icon');
                if (on) {
                    btn.classList.add('loading');
                    btn.setAttribute('aria-busy', 'true');
                    if (sendIcon) sendIcon.classList.add('visually-hidden');
                    if (spinner) spinner.classList.remove('visually-hidden');
                } else {
                    btn.classList.remove('loading');
                    btn.setAttribute('aria-busy', 'false');
                    if (sendIcon) sendIcon.classList.remove('visually-hidden');
                    if (spinner) spinner.classList.add('visually-hidden');
                }
            }

            // Thinking overlay utils (central overlay) - changes phrase while active and robust cleanup
            function ensureThinkingOverlay() {
                let overlay = document.getElementById('thinkingOverlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = 'thinkingOverlay';
                    overlay.className = 'thinking-overlay';
                    overlay.setAttribute('aria-hidden', 'true');
                    overlay.innerHTML = '<div class="thinking-icon"><i class="fa-solid fa-brain" aria-hidden="true"></i></div><div class="thinking-text" id="thinkingText">Pensando...</div>';
                    document.body.appendChild(overlay);
                }
                return overlay;
            }

            function startThinking() {
                // si hay uno previo, limpiarlo inmediatamente para evitar solapamientos
                if (__currentThinking && typeof __currentThinking.cleanup === 'function') {
                    try { __currentThinking.cleanup(); } catch (e) { /* silent */ }
                    __currentThinking = null;
                }

                __thinkingToken++;
                const myToken = __thinkingToken;

                const phrases = [
                    'Pensando',
                    'Analizando',
                    'Revisando fuentes',
                    'Formulando respuesta',
                    'Preparando',
                    'Comprobando',
                    'Sintetizando'
                ];

                const overlay = ensureThinkingOverlay();
                const textEl = overlay.querySelector('#thinkingText');

                // muestro overlay
                overlay.classList.add('visible');
                overlay.setAttribute('aria-hidden', 'false');

                // parameters for timing
                const dotIntervalMs = 420;           // update dots every tick
                const changePhraseMs = 2200;         // change phrase every ~2.2s
                const changeEveryTicks = Math.max(1, Math.round(changePhraseMs / dotIntervalMs));

                // start with a random phrase
                let currentPhrase = phrases[Math.floor(Math.random() * phrases.length)];
                let dots = 0;
                let tick = 0;
                if (textEl) textEl.textContent = currentPhrase + '...';

                const interval = setInterval(() => {
                    // si token invalidado, no seguimos (cleanup manejará)
                    if (myToken !== __thinkingToken) return;
                    tick++;
                    dots = (dots + 1) % 4;
                    // cada cierta cantidad de ticks cambiamos la frase aleatoriamente
                    if (tick % changeEveryTicks === 0) {
                        // elige otra frase distinta a la actual (si es posible)
                        let next = currentPhrase;
                        if (phrases.length > 1) {
                            while (next === currentPhrase) {
                                next = phrases[Math.floor(Math.random() * phrases.length)];
                            }
                        } else {
                            next = phrases[0];
                        }
                        currentPhrase = next;
                    }
                    if (textEl) textEl.textContent = currentPhrase + (dots ? '.'.repeat(dots) : '');
                }, dotIntervalMs);

                // fallback: si por alguna razón no se limpia, cerramos a los 30s
                const fallbackTimeout = setTimeout(() => {
                    try { cleanup(); } catch (e) {}
                }, 30000);

                function cleanup() {
                    // limpiamos interval y timeout, ocultamos overlay y spinner
                    try { clearInterval(interval); } catch (e) {}
                    try { clearTimeout(fallbackTimeout); } catch (e) {}
                    try { overlay.classList.remove('visible'); overlay.setAttribute('aria-hidden', 'true'); } catch (e) {}
                    try { setBtnLoading(false); } catch (e) {}
                    if (__currentThinking && __currentThinking.token === myToken) __currentThinking = null;
                }

                // activar spinner botón también para consistencia
                setBtnLoading(true);

                __currentThinking = {
                    token: myToken,
                    cleanup,
                    interval,
                    fallbackTimeout
                };

                return __currentThinking;
            }

            function stopThinking(tokenObj) {
                // Si nos pasan el objeto, llamamos cleanup directamente
                if (tokenObj && typeof tokenObj.cleanup === 'function') {
                    try { tokenObj.cleanup(); } catch (e) { /* silent */ }
                    if (__currentThinking && __currentThinking.token === tokenObj.token) __currentThinking = null;
                    return;
                }
                // Si no se pasa objeto, limpiamos el thinking activo (si existe)
                if (__currentThinking && typeof __currentThinking.cleanup === 'function') {
                    try { __currentThinking.cleanup(); } catch (e) { /* silent */ }
                    __currentThinking = null;
                    return;
                }
                // fallback: ocultar overlay y spinner
                const overlay = document.getElementById('thinkingOverlay');
                if (overlay) {
                    try { overlay.classList.remove('visible'); overlay.setAttribute('aria-hidden', 'true'); } catch (e) {}
                }
                setBtnLoading(false);
                __currentThinking = null;
            }

            // position chat input fixed above footer (NO movemos el DOM)
            function positionChatInput() {
                const centerCol = q('#colCenter');
                const chatInner = q('#chatInputInner');
                const footer = q('#nexusFooter');
                if (!centerCol || !chatInner || !footer) return;

                const rect = centerCol.getBoundingClientRect();
                const footerH = Math.ceil(footer.getBoundingClientRect().height || 0);
                const gap = 8;

                const vw = window.innerWidth || document.documentElement.clientWidth;
                if (vw <= 991) {
                    chatInner.style.left = '8px';
                    chatInner.style.width = (vw - 16) + 'px';
                    chatInner.style.maxWidth = (vw - 16) + 'px';
                } else {
                    const left = Math.max(8, rect.left + 8);
                    const width = Math.max(300, rect.width - 16);
                    chatInner.style.left = left + 'px';
                    chatInner.style.width = width + 'px';
                    chatInner.style.maxWidth = width + 'px';
                }
                chatInner.style.position = 'fixed';
                chatInner.style.bottom = (footerH + gap) + 'px';
                chatInner.style.zIndex = 1300;

                // for result area padding
                const computedH = chatInner.getBoundingClientRect().height || 72;
                document.documentElement.style.setProperty('--chat-input-height', computedH + 'px');
                qa('.result-area').forEach(el => el.style.paddingBottom = (computedH + 28) + 'px');
            }

            // stabilize position while parent columns transition (re-check during transition)
            function stabilizePositionDuringTransition(timeout = 700, threshold = 2, stableFrames = 3) {
                const chatInner = q('#chatInputInner');
                const centerCol = q('#colCenter');
                if (!chatInner || !centerCol) return Promise.resolve(false);

                let lastLeft = null, lastWidth = null, stableCount = 0;
                const start = performance.now();

                return new Promise(resolve => {
                    function step() {
                        const rect = centerCol.getBoundingClientRect();
                        const vw = window.innerWidth || document.documentElement.clientWidth;
                        let desiredLeft, desiredWidth;
                        if (vw <= 991) {
                            desiredLeft = 8;
                            desiredWidth = Math.max(300, vw - 16);
                        } else {
                            desiredLeft = Math.max(8, rect.left + 8);
                            desiredWidth = Math.max(300, rect.width - 16);
                        }

                        if (lastLeft === null) { lastLeft = desiredLeft; lastWidth = desiredWidth; stableCount = 1; }
                        else {
                            const dl = Math.abs(desiredLeft - lastLeft);
                            const dw = Math.abs(desiredWidth - lastWidth);
                            if (dl <= threshold && dw <= threshold) stableCount++; else stableCount = 1;
                            lastLeft = desiredLeft; lastWidth = desiredWidth;
                        }

                        // apply
                        chatInner.style.left = desiredLeft + 'px';
                        chatInner.style.width = desiredWidth + 'px';
                        chatInner.style.maxWidth = desiredWidth + 'px';
                        positionChatInput(); // update bottom/padding too

                        if (stableCount >= stableFrames) return resolve(true);
                        if (performance.now() - start > timeout) return resolve(false);
                        requestAnimationFrame(step);
                    }
                    requestAnimationFrame(step);
                });
            }

            document.addEventListener('DOMContentLoaded', () => {
                const textarea = q('#chatInput');
                const chatInner = q('#chatInputInner');
                const sendBtn = q('#sendChat');
                const chatOutputEl = q('#chatOutput');

                // autosize textarea
                function autoResize(el) {
                    if (!el) return;
                    el.style.height = 'auto';
                    const max = 320;
                    const newH = Math.min(el.scrollHeight, max);
                    el.style.height = newH + 'px';
                    positionChatInput();
                }
                if (textarea) {
                    autoResize(textarea);
                    textarea.addEventListener('input', () => {
                        // si el usuario empieza a escribir (o modifica el texto) ocultamos la overlay inmediatamente
                        stopThinking();
                        autoResize(textarea);
                    });

                    // focus/blur visual indicator (adds class to container)
                    textarea.addEventListener('focus', () => {
                        if (chatInner) chatInner.classList.add('has-focus');
                    });
                    textarea.addEventListener('blur', () => {
                        if (chatInner) chatInner.classList.remove('has-focus');
                    });

                    textarea.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            sendBtn.click();
                        }
                    });
                }

                // typewriter (cancellable)
                async function typeWriteInto(el, html, speed = 6) {
                    if (!el) return;
                    __typeToken++;
                    const myToken = __typeToken;
                    el.setAttribute('data-content', html);
                    const parentScroll = el.closest('.result-area') || el.parentElement;
                    el.innerHTML = '';
                    let i = 0;
                    return new Promise(resolve => {
                        function step() {
                            if (myToken !== __typeToken) return resolve();
                            i++;
                            el.innerHTML = html.slice(0, i);
                            try { if (parentScroll) parentScroll.scrollTop = parentScroll.scrollHeight; } catch (e) {}
                            if (i < html.length) setTimeout(step, speed); else resolve();
                        }
                        step();
                    });
                }

                function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

                // ---------------------------
                // sendMessage con "fase de pensamiento" (overlay central)
                // ---------------------------
                async function sendMessage() {
                    const text = textarea?.value?.trim();
                    if (!text) return;
                    let thinking = null;
                    try {
                        // fase de pensamiento: delay aleatorio antes de enviar la petición
                        const minDelay = 700;
                        const maxDelay = 1600;
                        const randomDelay = Math.floor(Math.random() * (maxDelay - minDelay + 1)) + minDelay;

                        // iniciamos la animación/estado de thinking (overlay central)
                        thinking = startThinking();

                        // espera simulada (la overlay permanecerá visible)
                        await sleep(randomDelay);

                        await stabilizePositionDuringTransition(900);
                        const resp = await fetch('@Url.Action("ChatAjax", "Nexus")', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ caseCode: '@Model.CaseCode', message: text })
                        });

                        // al recibir la respuesta (antes de escribir la salida) quitamos la overlay
                        stopThinking(thinking);

                        if (!resp.ok) throw new Error(resp.statusText);
                        const data = await resp.json();

                        // Como precaución: si al parsear la respuesta hay error, también quitamos thinking (ya hecho) y mostramos error
                        const html = marked.parse(data.response || '');
                        await typeWriteInto(chatOutputEl, html, 6);

                        textarea.value = ''; autoResize(textarea);
                        try { textarea.focus({ preventScroll: true }); } catch (e) { textarea.focus(); }
                    } catch (err) {
                        // en caso de error también garantizamos limpiar overlay
                        console.error(err);
                        stopThinking(thinking);
                        alert('Error: ' + (err && err.message ? err.message : 'Error en la petición'));
                    } finally {
                        positionChatInput();
                    }
                }
                if (sendBtn) sendBtn.addEventListener('click', sendMessage);

                // initialize content
                if (chatOutputEl) {
                    const content = chatOutputEl.getAttribute('data-content') || '';
                    if (content) chatOutputEl.innerHTML = content;
                }

                // bind table rows -> preview
                function bindTableRows() {
                    qa('.source-row').forEach(row => {
                        const clone = row.cloneNode(true);
                        row.parentNode.replaceChild(clone, row);
                    });
                    qa('.source-row').forEach(row => {
                        row.addEventListener('click', (ev) => { ev.stopPropagation(); onSelectRow(row); });
                        row.addEventListener('dblclick', (ev) => { ev.stopPropagation(); onSelectRow(row); const url = row.dataset.url; if (url) window.open(url, '_blank'); });
                    });
                    updateShownCount();
                }

                function updateShownCount() {
                    const visible = qa('#sourcesTable .source-row').length;
                    const shownEl = q('#shownCount');
                    const leftCountEl = q('#leftCount');
                    if (shownEl) shownEl.textContent = visible;
                    if (leftCountEl) leftCountEl.textContent = visible;
                }

                const sourcesWrapper = q('#sourcesWrapper');
                const previewWrapper = q('#previewWrapper');
                const previewContent = q('#previewContent');
                const previewTitle = q('#previewTitle');
                const btnBackToList = q('#btnBackToList');
                const btnOpenInViewer = q('#btnOpenInViewer');
                const btnDownloadPreview = q('#btnDownloadPreview');
                const btnFlagPreview = q('#btnFlagPreview');
                let currentPreview = { url: '', type: '' };

                async function onSelectRow(row) {
                    qa('.source-row.selected').forEach(r => r.classList.remove('selected'));
                    row.classList.add('selected');

                    const url = row.dataset.url;
                    const type = (row.dataset.type || '').toLowerCase();
                    const title = row.title || (row.querySelector('td:nth-child(2)')?.innerText) || 'Documento';
                    previewTitle.textContent = title;

                    if (sourcesWrapper) sourcesWrapper.style.display = 'none';
                    if (previewWrapper) previewWrapper.style.display = 'block';

                    currentPreview = { url: url, type: type };
                    renderPreview(url, type);

                    // expand left and hide right
                    const leftCol = q('#colLeft'), centerCol = q('#colCenter'), rightCol = q('#colRight');
                    if (leftCol && centerCol) {
                        document.documentElement.classList.add('right-hidden');
                        leftCol.style.flex = '0 0 70%'; leftCol.style.maxWidth = '70%'; leftCol.style.width = '70%';
                        centerCol.style.flex = '0 0 30%'; centerCol.style.maxWidth = '30%'; centerCol.style.width = '30%';
                        if (rightCol) rightCol.setAttribute('aria-hidden', 'true');
                    }
                    await stabilizePositionDuringTransition(1000);
                    positionChatInput();
                }

                function backToList() {
                    __pdfRenderToken++;
                    if (previewContent) previewContent.innerHTML = '';
                    currentPreview = { url: '', type: '' };
                    if (previewWrapper) previewWrapper.style.display = 'none';
                    if (sourcesWrapper) sourcesWrapper.style.display = 'block';
                    qa('.source-row.selected').forEach(r => r.classList.remove('selected'));
                    const leftCol = q('#colLeft'), centerCol = q('#colCenter'), rightCol = q('#colRight');
                    if (leftCol && centerCol) {
                        document.documentElement.classList.remove('right-hidden');
                        leftCol.style.width = ''; leftCol.style.flex = ''; leftCol.style.maxWidth = '';
                        centerCol.style.width = ''; centerCol.style.flex = ''; centerCol.style.maxWidth = '';
                        if (rightCol) { rightCol.style.display = ''; rightCol.style.width = ''; rightCol.style.flex = ''; rightCol.style.maxWidth = ''; rightCol.setAttribute('aria-hidden','false'); }
                    }
                    setTimeout(() => { stabilizePositionDuringTransition(900).then(() => positionChatInput()); }, 40);
                }

                if (btnBackToList) btnBackToList.addEventListener('click', backToList);
                if (btnOpenInViewer) btnOpenInViewer.addEventListener('click', () => { if (!currentPreview.url) return alert('No hay documento en vista previa.'); window.open(currentPreview.url, '_blank'); });
                if (btnDownloadPreview) btnDownloadPreview.addEventListener('click', () => { if (!currentPreview.url) return alert('No hay documento seleccionado.'); const a = document.createElement('a'); a.href = currentPreview.url; a.download = currentPreview.url.split('/').pop() || 'download'; document.body.appendChild(a); a.click(); a.remove(); });
                if (btnFlagPreview) btnFlagPreview.addEventListener('click', () => { const selRow = q('.source-row.selected'); if (!selRow) return alert('Selecciona un documento primero.'); selRow.classList.toggle('marked'); });

                // PDF / IMG render (similar a antes)
                async function renderPreview(url, type) {
                    __pdfRenderToken++;
                    const myToken = __pdfRenderToken;
                    if (!previewContent) return;
                    previewContent.innerHTML = '';
                    previewContent.scrollTop = 0;
                    if (!url) {
                        previewContent.innerHTML = '<p class="text-muted">No se encontró la URL del documento.</p>';
                        return;
                    }
                    if (type !== 'pdf') {
                        const img = document.createElement('img');
                        img.src = url;
                        img.className = 'img-fluid rounded preview-image';
                        img.style.maxHeight = '100%';
                        img.style.width = '100%';
                        img.style.objectFit = 'contain';
                        img.onerror = () => { previewContent.innerHTML = '<p class="text-danger">Error al cargar la imagen.</p>'; };
                        previewContent.appendChild(img);
                        img.onload = () => { stabilizePositionDuringTransition(400).then(() => positionChatInput()); };
                        return;
                    }

                    const progressWrap = document.createElement('div');
                    progressWrap.className = 'pdf-progress-wrap mb-2';
                    progressWrap.innerHTML = `<div class="pdf-progress-label">Cargando PDF…</div>
                                              <div class="progress"><div class="progress-bar" role="progressbar" style="width:0%"></div></div>`;
                    previewContent.appendChild(progressWrap);

                    try {
                        const loadingTask = pdfjsLib.getDocument(url);
                        const pdf = await loadingTask.promise;
                        if (myToken !== __pdfRenderToken) { try { pdf.destroy?.(); } catch (e) {} return; }
                        const total = pdf.numPages;
                        const progressBar = progressWrap.querySelector('.progress-bar');
                        const pagesContainer = document.createElement('div');
                        pagesContainer.className = 'pdf-pages-container';
                        previewContent.appendChild(pagesContainer);

                        for (let p = 1; p <= total; p++) {
                            if (myToken !== __pdfRenderToken) { try { pdf.destroy?.(); } catch (e) {} return; }
                            const pageBox = document.createElement('div');
                            pageBox.className = 'pdf-page-box mb-3';
                            pageBox.setAttribute('data-page', p);
                            const loader = document.createElement('div');
                            loader.className = 'pdf-page-loader';
                            loader.innerText = `Cargando página ${p} de ${total}...`;
                            pageBox.appendChild(loader);
                            pagesContainer.appendChild(pageBox);

                            const page = await pdf.getPage(p);
                            const containerWidth = Math.max(300, previewContent.clientWidth || 800);
                            const unscaledViewport = page.getViewport({ scale: 1 });
                            const scale = Math.max(0.5, (containerWidth - 24) / unscaledViewport.width);
                            const viewport = page.getViewport({ scale });

                            const canvas = document.createElement('canvas');
                            canvas.width = viewport.width;
                            canvas.height = viewport.height;
                            canvas.style.width = '100%';
                            canvas.style.height = 'auto';
                            canvas.className = 'pdf-page-canvas rounded';

                            const ctx = canvas.getContext('2d');
                            try {
                                await page.render({ canvasContext: ctx, viewport: viewport }).promise;
                            } catch (errRender) {
                                console.error('Error renderizando página', p, errRender);
                                pageBox.innerHTML = `<div class="text-danger">Error al renderizar página ${p}</div>`;
                                continue;
                            }

                            pageBox.removeChild(loader);
                            pageBox.appendChild(canvas);
                            const caption = document.createElement('div');
                            caption.className = 'pdf-page-caption small text-muted mt-1';
                            caption.innerText = `Página ${p} / ${total}`;
                            pageBox.appendChild(caption);

                            const percent = Math.round((p / total) * 100);
                            if (progressBar) progressBar.style.width = percent + '%';
                            await new Promise(res => setTimeout(res, 20));
                        }

                        if (progressWrap && progressWrap.parentNode) progressWrap.parentNode.removeChild(progressWrap);
                        if (previewContent) { stabilizePositionDuringTransition(500).then(() => positionChatInput()); }
                    } catch (err) {
                        console.error('Error al cargar PDF completo', err);
                        previewContent.innerHTML = '<p class="text-danger">Error al cargar el PDF. Revisa CORS o la URL.</p>';
                        stabilizePositionDuringTransition(400).then(() => positionChatInput());
                    }
                }

                // init binds
                const btnRefresh = q('#btnRefreshSources');
                if (btnRefresh) btnRefresh.addEventListener('click', () => bindTableRows());
                bindTableRows();

                // observe changes & resize to keep input positioned
                window.addEventListener('resize', () => { positionChatInput(); stabilizePositionDuringTransition(); });
                const mo = new MutationObserver(() => { positionChatInput(); stabilizePositionDuringTransition(); });
                mo.observe(document.body, { childList: true, subtree: true });

                // initial layout adjustments
                setTimeout(() => { positionChatInput(); stabilizePositionDuringTransition(); }, 160);
            });

            // heights & footer handling (como antes)
            (function () {
                let __panelsTO = null;
                function detectHeaderFooter() {
                    const headerSelectors = ['header', '.navbar', '.topbar', '.site-header', '.main-header'];
                    const footerSelectors = ['#nexusFooter', 'footer.site-footer', '.site-footer', '.nexus-notice'];
                    function firstMatch(list) { for (const s of list) { const el = document.querySelector(s); if (el) return el; } return null; }
                    const explicitFooter = firstMatch(footerSelectors);
                    const explicitHeader = firstMatch(headerSelectors);

                    const fixedBottomCandidates = [];
                    Array.from(document.body.children).forEach(el => {
                        try {
                            const cs = getComputedStyle(el);
                            if ((cs.position === 'fixed' || cs.position === 'sticky') && cs.display !== 'none') {
                                const rect = el.getBoundingClientRect();
                                if (rect.bottom >= window.innerHeight - 2 || rect.bottom >= window.innerHeight - 80) {
                                    fixedBottomCandidates.push(el);
                                }
                            }
                        } catch (e) { }
                    });

                    return { header: explicitHeader, footer: explicitFooter, fixedBottoms: fixedBottomCandidates };
                }

                function applyHeights() {
                    try {
                        const det = detectHeaderFooter();
                        const headerH = det.header ? Math.ceil(det.header.getBoundingClientRect().height) : 0;

                        let footerH = 0;
                        if (det.footer) { try { footerH = Math.max(footerH, Math.ceil(det.footer.getBoundingClientRect().height)); } catch (e) {} }
                        det.fixedBottoms.forEach(e => { try { footerH = Math.max(footerH, Math.ceil(e.getBoundingClientRect().height)); } catch (e) {} });

                        const nexus = document.getElementById('nexusFooter');
                        if (nexus) {
                            nexus.style.position = 'fixed';
                            nexus.style.left = '0';
                            nexus.style.right = '0';
                            nexus.style.bottom = '0';
                            nexus.style.zIndex = '1200';
                            nexus.style.width = '100%';
                            try { footerH = Math.max(footerH, Math.ceil(nexus.getBoundingClientRect().height)); } catch (e) {}
                        }

                        document.documentElement.style.setProperty('--footer-height', (footerH || 72) + 'px');
                        document.body.style.paddingBottom = (footerH || 72) + 'px';

                        const extra = 6;
                        const available = Math.max(180, Math.floor(window.innerHeight - headerH - (footerH || 72) - extra));

                        const container = document.querySelector('.app-container');
                        if (container) container.style.minHeight = (window.innerHeight - headerH - (footerH || 72)) + 'px';

                        qa('.col-lg-3, .col-lg-5, .col-lg-4').forEach(col => {
                            col.style.display = 'flex';
                            col.style.flexDirection = 'column';
                            col.style.paddingBottom = '0';
                            col.style.marginBottom = '0';
                            col.style.minHeight = '0';
                        });

                        qa('.card.card-panel-left, .card.card-panel-center, .card.card-panel-right').forEach(card => {
                            card.style.display = 'flex';
                            card.style.flexDirection = 'column';
                            card.style.height = available + 'px';
                            card.style.maxHeight = available + 'px';
                            card.style.minHeight = '0';
                            card.style.marginBottom = '0';
                        });

                        qa('.card.card-panel-center, .card.card-panel-right').forEach(card => {
                            const body = card.querySelector('.card-body.panel-body');
                            if (body) {
                                body.style.flex = '1 1 auto';
                                body.style.minHeight = '0';
                                const result = body.querySelector('.result-area');
                                if (result) {
                                    result.style.flex = '1 1 auto';
                                    result.style.minHeight = '0';
                                    result.style.overflowY = 'auto';
                                }
                            }
                        });

                        qa('.card.card-panel-left .card-body.panel-body').forEach(body => {
                            body.style.flex = '1 1 auto';
                            body.style.minHeight = '0';
                            body.style.overflow = 'hidden';
                        });

                        const previewContent = document.querySelector('#previewContent');
                        if (previewContent) {
                            const panel = previewContent.closest('.panel-height') || previewContent.closest('.card-body.panel-body');
                            if (panel) {
                                const panelRect = panel.getBoundingClientRect();
                                const previewHeader = panel.querySelector('.d-flex.align-items-center') || panel.querySelector('.card-header');
                                const headerInnerH = previewHeader ? Math.ceil(previewHeader.getBoundingClientRect().height) : 48;
                                const footerCompact = panel.querySelector('.mt-2.d-flex') || panel.querySelector('.card-footer');
                                const footerInnerH = footerCompact ? Math.ceil(footerCompact.getBoundingClientRect().height) : 40;
                                const innerAvailable = Math.max(120, Math.floor(panelRect.height - headerInnerH - footerInnerH - 16));
                                previewContent.style.height = innerAvailable + 'px';
                                previewContent.style.maxHeight = innerAvailable + 'px';
                                previewContent.style.minHeight = '0';
                                previewContent.style.overflowY = 'auto';
                                previewContent.style.boxSizing = 'border-box';
                            }
                        }

                        qa('.pdf-pages-container, .pdf-page-box').forEach(el => { el.style.overflow = 'visible'; });

                        document.documentElement.style.setProperty('--available-panel-height', available + 'px');
                    } catch (err) {
                        console.warn('applyHeights error', err);
                    }
                }

                function scheduleApply() {
                    clearTimeout(__panelsTO);
                    __panelsTO = setTimeout(applyHeights, 80);
                }

                window.addEventListener('load', scheduleApply);
                window.addEventListener('resize', scheduleApply);
                const mo = new MutationObserver(() => scheduleApply());
                mo.observe(document.body, { childList: true, subtree: true });

                window.__setPanelsHeight = applyHeights;
                scheduleApply();
            })();
        })();
        </script>

        <style>
            :root{
                --page-bg:#f4f6f8;
                --muted:#6c757d;
                --brand-dark:#003090;
                --available-panel-height:600px;
                --footer-height:72px;
                --chat-input-height:72px;
            }

            html, body { height:100%; }
            body { margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--page-bg); color:#212529; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
            .app-container { padding:.6rem .8rem; box-sizing:border-box; min-height:100%; display:flex; flex-direction:column; }

            .layout-row { flex:1 1 auto; display:flex; gap:.25rem; align-items:stretch; }

            .small-header { color:#fff; padding:.45rem .75rem; border-radius:.35rem; }
            .center-header {
                background: linear-gradient(90deg, rgba(0,48,144,0.95) 0%, rgba(0,116,210,0.85) 55%, rgba(230,4,45,0.85) 100%);
                filter: saturate(.95);
            }
            .left-header, .right-header {
                background: linear-gradient(90deg, rgba(0,48,144,0.95) 0%, rgba(0,116,210,0.85) 100%);
                filter: saturate(.85);
            }

            .card-panel-left, .card-panel-right {
                background:#fff; border-radius:.45rem; border:1px solid rgba(16,24,40,0.04); box-shadow:none; display:flex; flex-direction:column; overflow:hidden;
            }
            .card-panel-center {
                background:#fff; border-radius:.45rem; border:1px solid rgba(16,24,40,0.04); box-shadow:0 8px 22px rgba(2,8,23,0.04); display:flex; flex-direction:column; overflow:hidden;
            }

            .left-col { position:relative; flex:0 0 33.3333%; max-width:33.3333%; transition: width 360ms ease, flex-basis 360ms ease; }
            .center-col { position:relative; flex:0 0 41.6666%; max-width:41.6666%; transition: width 360ms ease, flex-basis 360ms ease; }
            .right-col { position:relative; flex:0 0 25%; max-width:25%; transition: width 360ms ease, flex-basis 360ms ease; }

            html.right-hidden .right-col {
                display:none !important; width:0 !important; max-width:0 !important; flex:0 0 0 !important; padding:0 !important; margin:0 !important; visibility:hidden !important;
            }

            .panel-body { padding:.5rem !important; box-sizing:border-box; display:flex; flex-direction:column; overflow:hidden; }
            .panel-height { height:var(--available-panel-height,auto) !important; max-height:var(--available-panel-height,none) !important; min-height:360px; display:flex; flex-direction:column; overflow:hidden; }
            .card-body.panel-body { flex:1 1 auto; min-height:0; display:flex; flex-direction:column; }

            .thumb-wrap { width:44px; height:44px; display:flex; align-items:center; justify-content:center; border-radius:.35rem; background:#fff; border:1px solid rgba(0,0,0,0.04); }
            .thumb-img { width:100%; height:100%; object-fit:cover; display:block; }
            .source-row { transition: all .12s ease; padding:.28rem .45rem; }
            .source-row:hover { background: rgba(13,110,253,0.03); transform: translateY(-1px); }
            .source-row.selected { background: rgba(13,110,253,0.045); border-left:4px solid rgba(0,48,144,0.12); }

            .center-header .header-title { font-size:1.25rem; font-weight:600; color:#fff; }
            #btnBackPage { padding:.5rem .9rem; font-size:0.95rem; box-shadow:0 6px 14px rgba(2,8,23,0.06); }

            .result-panel { background:#fff; color:#222; border-radius:.45rem; min-height:160px; border:1px solid rgba(30,41,59,0.04); box-shadow:0 6px 18px rgba(2,8,23,0.04); }

            /* result-area clearance (uses --chat-input-height var updated by JS) */
            .result-area { padding-bottom: calc(var(--chat-input-height,72px) + 28px); overflow-y:auto; }

            /* Chat input: fixed by JS, but keep styling here */
            .chat-input-wrapper { display:block; height:0; }
            .chat-input-inner {
                position: relative;
                background: #ffffff;
                border-radius: 12px;
                padding: 12px 64px 12px 16px;
                box-shadow: 0 10px 26px rgba(2,8,23,0.06);
                border:1px solid rgba(18,29,40,0.04);
                box-sizing: border-box;
                max-width: 900px;
                margin: 0 auto;
                transition: box-shadow .16s ease, transform .12s ease, border-color .16s ease;
            }
            .chat-input-inner .chat-input {
                background: transparent;
                border:none;
                box-shadow:none;
                resize:none;
                outline:none;
                width:100%;
                padding:0;
                min-height:56px;      /* un poco más alto */
                max-height:260px;
                font-size:1.15rem;    /* tamaño aumentado */
                line-height:1.4;
                color:#222;
            }

            /* -- FOCUS VISUALS: cuando el textarea tiene foco (o .has-focus se añade via JS) -- */
            .chat-input-inner.has-focus {
                box-shadow: 0 18px 44px rgba(2,8,23,0.10), 0 0 0 8px rgba(0,116,210,0.06);
                border-color: rgba(0,116,210,0.95);
                transform: translateY(-2px);
            }
            /* mejora accesibilidad: foco directo sobre textarea también resalta */
            .chat-input-inner .chat-input:focus { outline: none; }
            .chat-input-inner:focus-within { /* extra safety on supporting browsers */ }
            /* sutil animación al entrar/salir */
            .chat-input-inner.has-focus { transition: box-shadow .18s ease, border-color .18s ease, transform .12s ease; }

            .chat-send-btn {
                position:absolute;
                right:12px;
                top:50%;
                transform:translateY(-50%);
                border:none;
                background:#ffffff;
                width:52px;
                height:52px;
                border-radius:50%;
                box-shadow:0 8px 22px rgba(2,8,23,0.08);
                display:flex;
                align-items:center;
                justify-content:center;
                cursor:pointer;
                color:var(--brand-dark);
                transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
                overflow:visible;
                z-index:1400;
            }
            .chat-send-btn .send-icon, .chat-send-btn .spinner-icon { display:inline-flex; align-items:center; justify-content:center; width:22px; height:22px; }
            .chat-send-btn .spinner-icon.visually-hidden { display:none; }
            .chat-send-btn.loading .send-icon { display:none; }
            .chat-send-btn.loading .spinner-icon { display:inline-flex; }
            .chat-send-btn:hover { transform: translateY(-52%) scale(1.03); box-shadow:0 12px 30px rgba(2,8,23,0.10); }
            .chat-send-btn:active { transform: translateY(-50%) scale(0.98); }

            /* Thinking overlay central (grande, centrado) */
            .thinking-overlay {
              position: fixed;
              left: 50%;
              top: 50%;
              transform: translate(-50%, -50%) scale(1);
              padding: 18px 26px;
              border-radius: 14px;
              min-width: 260px;
              max-width: 90%;
              box-sizing: border-box;
              font-size: 1.15rem;
              line-height: 1.25;
              text-align: center;
              box-shadow: 0 18px 40px rgba(2,8,23,0.18);
              background: linear-gradient(90deg, rgba(0,48,144,0.98) 0%, rgba(0,116,210,0.92) 55%, rgba(230,4,45,0.92) 100%);
              color: #fff;
              z-index: 2400;
              opacity: 0;
              pointer-events: none;
              transition: opacity .18s ease, transform .18s cubic-bezier(.2,.9,.2,1);
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 10px;
            }

            /* Version visible */
            .thinking-overlay.visible {
              opacity: 1;
              pointer-events: auto;
              transform: translate(-50%, -50%) scale(1);
            }

            .thinking-overlay .thinking-text {
              font-weight: 600;
              font-size: 1.17rem;
            }

            .thinking-overlay .thinking-icon {
              width: 34px;
              height: 34px;
              border-radius: 8px;
              background: rgba(255,255,255,0.08);
              display:flex;
              align-items:center;
              justify-content:center;
              font-size:18px;
            }

            /* FOOTER: degradado de marca (parecido al header central) */
            .nexus-notice {
                position: fixed;
                left: 0;
                right: 0;
                bottom: 0;
                z-index: 1200;
                background: linear-gradient(90deg,
                            rgba(0,48,144,0.95) 0%,
                            rgba(0,116,210,0.85) 55%,
                            rgba(230,4,45,0.85) 100%);
                color: #fff;
                padding: .75rem 1rem;
                box-shadow: 0 -6px 18px rgba(2,8,23,0.06);
                display:flex;
                align-items:center;
                justify-content:center;
                font-size:0.95rem;
                height: var(--footer-height,72px);
                box-sizing: border-box;
                border-top: 1px solid rgba(11,43,74,0.06);
            }
            .nexus-notice .nexus-inner { text-align:center; width:100%; max-width:1200px; color: #fff; }

            @@media (max-width:991px) {
                .left-col, .center-col, .right-col { flex:0 0 100%; max-width:100%; }
                main.col-lg-5 { order:2; width:100%; }
                aside.col-lg-4:first-of-type { order:1; }
                aside.col-lg-3:last-of-type { order:3; }
                .chat-send-btn { width:44px; height:44px; right:10px; }
                .nexus-notice { height:auto; padding:.6rem; }
                #btnBackPage { font-size:0.9rem; padding:.45rem .75rem; }
            }
        </style>
}

@functions {
    public string RenderMarkdown(string markdown)
    {
        if (string.IsNullOrEmpty(markdown)) return string.Empty;
        var pipeline = new MarkdownPipelineBuilder().UseAdvancedExtensions().Build();
        return Markdig.Markdown.ToHtml(markdown, pipeline);
    }
}

@model app_tramites.Models.ModelAi.ProcessCase
@using Markdig
@{
    Layout = "_Layout"; // o el layout que uses
}


<div class="container-fluid app-container">
    <div class="row g-1 layout-row">
        <!-- LEFT: Tabla de Fuentes / Documentos -->
        <aside class="col-lg-2 left-col" id="colLeft">
            <div class="card card-panel-left rounded-3 h-100">
                <div class="card-header d-flex align-items-center justify-content-between small-header left-header">
                    <div class="d-flex align-items-center gap-2">
                        <i class="fa fa-folder-open me-2"></i>
                        <strong id="leftHeaderTitle">Fuentes: <small class="text-muted" id="leftCount">@((Model.DataFile?.Count() ?? 0))</small></strong>
                    </div>
                </div>

                <div class="card-body p-2 panel-body panel-height d-flex flex-column">
                    <div id="sourcesWrapper" style="display:block; flex:1 1 auto;">
                        <table id="sourcesTable" class="table table-borderless table-hover mb-0" style="width:100%;">
                            <thead class="d-none"></thead>
                            <tbody>
                                @foreach (var file in Model.DataFile)
                                {
                                    var origName = file.IsFileUri ? file.FileUri : file.FileUri;
                                    var ext = System.IO.Path.GetExtension(origName)?.ToLower().TrimStart('.') ?? "";
                                    var url = file.FileUri;
                                    var type = (ext == "pdf") ? "pdf" : (ext == "jpg" || ext == "jpeg" || ext == "png" || ext == "webp") ? "img" : "other";
                                                <tr class="source-row" data-url="@url" data-type="@type" data-ext="@ext" title="@System.IO.Path.GetFileName(origName)" style="cursor:pointer;">
                                                    <td style="width:56px; padding:.5rem;">
                                                        <div class="thumb-wrap">
                                                @if (ext == "pdf")
                                                {
                                                                            <i class="fa fa-file-pdf fa-lg text-danger"></i>
                                                }
                                                else
                                                {
                                                                            <img src="@url" class="thumb-img" onerror="this.style.display='none';" />
                                                }
                                                        </div>
                                                    </td>
                                                    <td class="align-middle">
                                                        <div class="fw-semibold text-truncate">@System.IO.Path.GetFileName(origName)</div>
                                                        <small class="text-muted">@ext.ToUpper()</small>
                                                    </td>
                                                    <td class="text-end align-middle" style="width:36px;">
                                                        <i class="fa fa-chevron-right text-muted"></i>
                                                    </td>
                                                </tr>
                                }
                            </tbody>
                        </table>
                    </div>

                    <div id="previewWrapper" style="display:none; flex:1 1 auto;">
                        <div class="d-flex align-items-center justify-content-between mb-2">
                            <div class="fw-semibold" id="previewTitle">Vista previa</div>
                            <div class="d-flex gap-1">
                                <button id="btnBackToList" class="btn btn-sm btn-outline-secondary" title="Volver al listado"><i class="fa fa-arrow-left"></i> Volver</button>
                               
                                <button id="btnDownloadPreview" class="btn btn-sm btn-light" title="Descargar"><i class="fa fa-download"></i></button>

                                <!-- Zoom controls -->
                                <div class="btn-group ms-2" role="group" aria-label="Zoom controls">
                                    <button id="btnZoomOut" type="button" class="btn btn-sm btn-light" title="Zoom - (tecla '-')"><i class="fa fa-search-minus"></i></button>
                                    <button id="btnZoomReset" type="button" class="btn btn-sm btn-light" title="Reset zoom (tecla 0)"><i class="fa fa-ban"></i></button>
                                    <button id="btnZoomIn" type="button" class="btn btn-sm btn-light" title="Zoom + (tecla '+')"><i class="fa fa-search-plus"></i></button>
                                </div>

                            </div>
                        </div>

                        <div id="previewContent" style="width:100%; height:100%; min-height:240px;">
                        </div>
                    </div>

                    <div class="mt-2 d-flex justify-content-between align-items-center small">
                        <div class="text-muted">Mostrar: <span id="shownCount">0</span></div>
                        <div>
                            <button id="btnRefreshSources" class="btn btn-sm btn-outline-secondary" title="Refrescar lista"><i class="fa fa-sync"></i></button>
                        </div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- CENTER: Chat / Resultados -->
        <main class="col-lg-8 center-col" id="colCenter">
            <div class="card card-panel-center rounded-3 h-100">
                <div class="card-header d-flex align-items-center justify-content-between small-header center-header">
                    <div class="d-flex align-items-center gap-2">
                        <h5 class="mb-0 header-title">Resultados del Caso</h5>
                    </div>
                    <div class="card-header d-flex align-items-center justify-content-between small-header center-header">
                        <div class="d-flex align-items-center gap-2">
                            <a asp-action="Index" onclick="cargando()"
                               class="btn btn-primary btn-lg d-flex align-items-center gap-2"
                               id="btnBackPage" title="Volver">
                                <i class="fa fa-arrow-left"></i>
                                <span>Volver</span>
                            </a>
                        </div>

                        <div class="d-flex align-items-center gap-2">
                            <button id="btnExportPdf" type="button"
                                    class="btn btn-primary btn-lg d-flex align-items-center gap-2"
                                    title="Exportar resultados a PDF">
                                <i class="fa fa-file-pdf me-1" aria-hidden="true"></i>
                                <span>Exportar PDF</span>
                            </button>
                        </div>
                    </div>


                </div>

                <div class="card-body d-flex flex-column panel-body panel-height">
                    <div class="mb-2 text-muted medium">
                        <b>NE-@(((Model.CaseCode.ToString() ?? "").Split('-').FirstOrDefault() ?? ""))</b>
                        @if (Model.FinalResponseResults?.Any() == true)
                        {
                            var lastDate = Model.FinalResponseResults.OrderByDescending(r => r.CreatedDate).FirstOrDefault()?.CreatedDate;
                            if (lastDate != null)
                            {
                                                        <span class="mx-2">·</span>
                                                        <span>@lastDate.Value.ToLocalTime().ToString("dd/MM/yyyy, HH:mm")</span>
                                ;
                            }
                        }
                    </div>

                    <!-- RESULT AREA -->
                    <div class="flex-grow-1 result-area mb-2">
                        <div class="result-panel p-3 h-100">
                            @if (!Model.FinalResponseResults.Any())
                            {
                                            <div class="alert alert-warning text-center mb-0">
                                                <i class="fa fa-info-circle me-2"></i>No hay resultados disponibles para este caso.
                                            </div>
                            }
                            else
                            {
                                var allMarkdown = string.Join("\n\n---\n\n",
                                Model.FinalResponseResults.OrderBy(r => r.CreatedDate).Select(r => r.ResponseText ?? ""));
                                var html = RenderMarkdown(allMarkdown);
                                            <div id="chatOutput" data-content='@Html.Raw(html.Replace("\"", "&quot;"))' style="font-size:15px; line-height:1.6; color:#222;"></div>
                            }
                        </div>
                    </div>

                    <!-- Chat input container: quedará fixed sobre footer (NO movido en DOM) -->
                    <div class="chat-input-wrapper" id="chatInputWrapper" aria-hidden="false">
                        <div class="chat-input-inner" id="chatInputInner" role="region" aria-label="Chat input area">
                            <textarea id="chatInput" class="chat-input form-control" rows="2" placeholder="Comienza a escribir... (Enter = enviar, Shift+Enter = nueva línea)"></textarea>

                            <button id="sendChat" class="chat-send-btn" title="Enviar" aria-label="Enviar" type="button" aria-busy="false">
                                <span class="send-icon" aria-hidden="true"><i class="fa-solid fa-paper-plane"></i></span>
                                <span class="spinner-icon visually-hidden" aria-hidden="true"><i class="fa-solid fa-spinner fa-spin"></i></span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- RIGHT: Studio / Acciones -->
        <aside class="col-lg-1 right-col" id="colRight" aria-hidden="false">
            <div class="card card-panel-right rounded-3 h-100">
                <div class="card-header d-flex align-items-center justify-content-between small-header right-header">
                    <div><strong>Studio</strong></div>
                    <small class="text-muted"></small>
                </div>
                <div class="card-body d-flex flex-column panel-body panel-height studio-panel-body">
                    <!-- START: Studio tiles -->
                    <div class="studio-grid" aria-hidden="false">
                        <button id="studioAudio" class="studio-tile tile-audio" title="Validación contractual" type="button" aria-label="Validación contractual">
                            <div class="tile-top">
                                <div class="tile-icon"><i class="fa fa-wave-square"></i></div>
                                <div class="tile-menu"><i class="fa fa-ellipsis-vertical"></i></div>
                            </div>
                            <div class="tile-body">
                                <div class="tile-title">Contratos</div>
                            </div>
                        </button>

                        <button id="studioVideo" class="studio-tile tile-video" title="Alertas y Hallazgos" type="button" aria-label="Alertas y Hallazgos">
                            <div class="tile-top">
                                <div class="tile-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                                <div class="tile-menu"><i class="fa fa-ellipsis-vertical"></i></div>
                            </div>
                            <div class="tile-body">
                                <div class="tile-title">Alertas</div>
                            </div>
                        </button>

                        <button id="studioMind" class="studio-tile tile-mind" title="Facturas" type="button" aria-label="Facturas">
                            <div class="tile-top">
                                <div class="tile-icon"><i class="fa fa-money-bill-wave"></i></div>
                                <div class="tile-menu"><i class="fa fa-ellipsis-vertical"></i></div>
                            </div>
                            <div class="tile-body">
                                <div class="tile-title">Facturas</div>
                            </div>
                        </button>
                         
                    </div>
                    <hr class="my-2" />

                    <!-- START: Notes list (colocar entre .studio-grid y el <hr>) -->
                    @* Notes panel mejorado: coloca este bloque donde quieras en el panel derecho *@
                    <div class="notes-section shadow-sm rounded p-2 bg-white" aria-live="polite" style="border-left:4px solid #0d6efd;">
                        <div class="d-flex align-items-center justify-content-between mb-2">
                            <div class="fw-semibold">Notas del auditor</div>
                            <div class="d-flex gap-2 align-items-center">
                                <button id="btnAddNote" type="button" class="btn btn-sm btn-primary" title="Agregar nota">
                                    <i class="fa fa-plus me-1"></i>Agregar
                                </button>
                                <button id="btnRefreshNotes" type="button" class="btn btn-sm btn-outline-secondary" title="Refrescar">
                                    <i class="fa fa-sync"></i>
                                </button>
                            </div>
                        </div>

                        <div id="notesList" class="notes-list list-group mb-2" role="list" style="max-height:280px; overflow:auto;">
                            <!-- Items se insertan aquí por JS: cada item tendrá clase .list-group-item -->
                            <div class="text-muted small text-center py-3">Cargando notas...</div>
                        </div>

                        <!-- Editor (inicialmente oculto) -->
                        <div id="notesEditor" class="notes-editor card p-2" aria-hidden="true" style="display:none;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <div class="fw-semibold" id="notesEditorTitle">Nueva nota</div>
                                <div>
                                    <button id="notesCancel" type="button" class="btn btn-sm btn-light">Cancelar</button>
                                    <button id="notesSave" type="button" class="btn btn-sm btn-primary ms-2">Guardar</button>
                                </div>
                            </div>

                            <div class="mb-2">
                                <input id="noteTitle" class="form-control form-control-sm" placeholder="Título (opcional)" />
                            </div>

                            <div class="mb-2">
                                <textarea id="noteDetail" rows="5" class="form-control form-control-sm" placeholder="Escribe la nota..."></textarea>
                            </div>

                            <div class="d-flex justify-content-between align-items-center">
                                <small class="text-muted">Notas guardadas en el caso</small>
                                <div id="notesStatus" class="small text-muted"></div>
                            </div>
                        </div>
                    </div>
                    <!-- END: Notes list -->

                    <div class="mt-auto">
                        <div id="cfTopPanel" class="cf-top-panel mt-2" data-case="@Model.CaseCode">
                            <div class="cf-question fw-semibold mb-2">¿Nexus facilitó tu auditoría de este caso?</div>
                            <div class="cf-toggle d-flex gap-2 mb-3" role="radiogroup" aria-label="¿Nexus facilitó tu auditoría de este caso?">
                                <br />
                                <button type="button" class="cf-toggle-btn" data-value="true" aria-pressed="false" title="Sí — Nexus facilitó">
                                    <div class="tile-top">
                                        <div class="tile-icon"><i class="fa fa-thumbs-up"></i></div>
                                    </div>
                                    <div class="tile-body">
                                        <div class="tile-title">Sí</div>
                                    </div>
                                </button>
                                <button type="button" class="cf-toggle-btn" data-value="false" aria-pressed="false" title="No — No facilitó">
                                    <div class="tile-top">
                                        <div class="tile-icon"><i class="fa fa-thumbs-down"></i></div>
                                    </div>
                                    <div class="tile-body">
                                        <div class="tile-title">No</div>
                                    </div>
                                </button>
                            </div>

                            <div class="cf-comment mb-2">
                                <label class="form-label small mb-1">¿Quieres dejar algún comentario? (opcional)</label>
                                <textarea id="cfComment" class="form-control form-control-sm" rows="3" placeholder="Ej. Lo que más ayudó fue..., o mejorar..."></textarea>
                            </div>

                            <div class="d-flex justify-content-between align-items-center">
                                <div id="cfStatus" class="small text-muted"></div>
                                <div>
                                    <button id="cfSend" type="button" class="btn btn-sm btn-primary">Enviar reseña</button>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </aside>
    </div>
</div>
<footer id="nexusFooter" class="nexus-notice site-footer" role="contentinfo" aria-hidden="false">
    <div class="nexus-inner">
        <strong>Nexus puede cometer errores.</strong> Comprueba la información importante antes de tomar decisiones.
    </div>
</footer>

@section Scripts {
                <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
                <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.3/html2pdf.bundle.min.js"></script>
    <script>
        // Reemplaza sólo el listener / lógica de export por este bloque
        document.addEventListener('DOMContentLoaded', () => {
          const exportBtn = document.getElementById('btnExportPdf');
          if (!exportBtn) return;

          const caseCode = '@Model.CaseCode';
          const caseDateStr = '@((Model.FinalResponseResults != null && Model.FinalResponseResults.Any()) ? Model.FinalResponseResults.OrderByDescending(r => r.CreatedDate).FirstOrDefault()?.CreatedDate.ToLocalTime().ToString("dd/MM/yyyy, HH:mm") : "")';
          const filesCount = @(Model.DataFile?.Count() ?? 0);

          function pad(n){ return String(n).padStart(2,'0'); }
          function formatDate(d){ try { return `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${d.getFullYear()} ${pad(d.getHours())}:${pad(d.getMinutes())}`; } catch(e){ return d.toString(); } }
          function escapeHtml(s){ if(!s) return ''; return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m]); }

          exportBtn.addEventListener('click', async (ev) => {
            ev.preventDefault();
            exportBtn.disabled = true;
            const orig = exportBtn.innerHTML;
            exportBtn.innerHTML = '<i class="fa fa-spinner fa-spin me-1"></i> Generando...';

            try {
              // esperar fuentes para que iconos se rendericen
              if (document.fonts && document.fonts.ready) {
                try { await document.fonts.ready; } catch(_) {}
              }

              const chatOut = document.getElementById('chatOutput');
              if (!chatOut) throw new Error('No se encontró #chatOutput');

              // Contenedor a rasterizar: NO incluimos cabecera ni "Resumen"
              const docWrap = document.createElement('div');
              docWrap.style.boxSizing = 'border-box';
              docWrap.style.padding = '8px 12px';
              docWrap.style.fontFamily = getComputedStyle(document.body).fontFamily || 'Arial, sans-serif';
              docWrap.style.color = getComputedStyle(document.body).color || '#222';
              docWrap.style.background = '#fff';
              docWrap.style.width = '100%';

              // CSS para evitar cortes internos
              const avoidBreakCss = `
                .chat-response, .chat-response-final, .chat-divider, .note-detail, .pdf-page-box {
                  page-break-inside: avoid;
                  break-inside: avoid;
                  -webkit-column-break-inside: avoid;
                  -ms-break-inside: avoid;
                }
                img { page-break-inside: avoid; break-inside: avoid; max-width:100%; }
                p, div, li, pre { widows: 3; orphans: 3; }
                * { -webkit-hyphens: none; -ms-hyphens: none; hyphens: none; }
              `;
              const styleEl = document.createElement('style');
              styleEl.innerHTML = avoidBreakCss;
              docWrap.appendChild(styleEl);

              // Clonar sólo el contenido del chat (sin encabezado ni resumen)
              const contentClone = chatOut.cloneNode(true);
              contentClone.querySelectorAll('textarea, input, button, .chat-input, .chat-send-btn').forEach(n => n.remove());
              contentClone.style.marginTop = '0';
              contentClone.style.width = '100%';
              docWrap.appendChild(contentClone);

              // Opciones: reservamos espacio superior (margin top) para la cabecera
              // Ajusta top (en mm) según el tamaño de la cabecera. Aquí uso 26 mm.
              const now = new Date();
              const filename = `NE-${caseCode || 'case'}_report_${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}.pdf`;
              const opt = {
                margin: [26, 10, 14, 10], // top, left, bottom, right (mm) -> top aumentado para espacio cabecera
                filename: filename,
                image: { type: 'jpeg', quality: 0.98 },
                html2canvas: {
                  scale: 2,
                  useCORS: true,
                  allowTaint: false,
                  logging: false,
                  windowWidth: docWrap.scrollWidth || document.documentElement.clientWidth
                },
                jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' },
                pagebreak: { mode: ['css', 'legacy'] }
              };

              // Generar PDF y luego dibujar la cabecera en cada página
              const worker = html2pdf().set(opt).from(docWrap).toPdf();
              worker.get('pdf').then(function(pdf) {
                try {
                  const total = pdf.internal.getNumberOfPages();
                  const pageW = pdf.internal.pageSize.getWidth();
                  const marginLeft = 10;
                  const marginRight = 10;
                  const genDateStr = formatDate(now);

                  for (let i = 1; i <= total; i++) {
                    pdf.setPage(i);

                    // Dibujar cabecera (texto a ~12-16 mm desde el borde superior)
                    pdf.setFontSize(10);
                    pdf.setTextColor(34,34,34);
                    pdf.text(`Caso: ${String(caseCode)}`, marginLeft, 12);

                    pdf.setFontSize(8);
                    pdf.setTextColor(100,100,100);
                    pdf.text(`Fecha del caso: ${String(caseDateStr)}`, marginLeft, 16);

                    // Derechos (alineado a la derecha)
                    pdf.setFontSize(8);
                    pdf.text(`Generado: ${genDateStr}`, pageW - marginRight, 12, { align: 'right' });
                    pdf.text(`Ficheros: ${filesCount}`, pageW - marginRight, 16, { align: 'right' });

                    // Línea separadora bajo cabecera
                    pdf.setDrawColor(220);
                    pdf.setLineWidth(0.4);
                    pdf.line(marginLeft, 19, pageW - marginRight, 19);
                  }
                } catch (errHead) {
                  console.warn('No se pudo añadir cabecera por página:', errHead);
                }
                pdf.save(filename);
              }).catch(err => {
                console.error('html2pdf get(pdf) error:', err);
                // fallback sin await
                html2pdf().set(opt).from(docWrap).save().catch(e => {
                  console.error('Fallback html2pdf.save error:', e);
                  alert('No se pudo generar el PDF automáticamente. Revisa la consola.');
                });
              });

            } catch (err) {
              console.error('Export error:', err);
              alert('No se pudo generar el PDF: ' + (err && err.message ? err.message : err));
            } finally {
              exportBtn.disabled = false;
              exportBtn.innerHTML = orig;
            }
          });
        });
    </script>



                <script>


                    (function () {
                        let __pdfRenderToken = 0;
                        let __typeToken = 0;
                        let __thinkingToken = 0;
                        let __currentThinking = null;


                                let __lastManualScrollAt = 0;
                                document.addEventListener('scroll', (ev) => {
                                    try {
                                        const target = ev.target;
                                        // si el scroll ocurrió dentro de un contenedor .result-area (o un hijo), lo consideramos manual
                                        if (target && target.closest && (target.classList && target.classList.contains('result-area') || target.closest('.result-area'))) {
                                            __lastManualScrollAt = Date.now();
                                        }
                                    } catch (e) { /* ignore */ }
                                }, true);

                        function q(sel) { return document.querySelector(sel); }
                        function qa(sel) { return Array.from(document.querySelectorAll(sel)); }


                        function setBtnLoading(on) {
                            const btn = q('#sendChat'); if (!btn) return;
                            const sendIcon = btn.querySelector('.send-icon');
                            const spinner = btn.querySelector('.spinner-icon');
                            if (on) {
                                btn.classList.add('loading');
                                btn.setAttribute('aria-busy', 'true');
                                if (sendIcon) sendIcon.classList.add('visually-hidden');
                                if (spinner) spinner.classList.remove('visually-hidden');
                            } else {
                                btn.classList.remove('loading');
                                btn.setAttribute('aria-busy', 'false');
                                if (sendIcon) sendIcon.classList.remove('visually-hidden');
                                if (spinner) spinner.classList.add('visually-hidden');
                            }
                        }

                        function ensureThinkingOverlay() {
                            let overlay = document.getElementById('thinkingOverlay');
                            if (!overlay) {
                                overlay = document.createElement('div');
                                overlay.id = 'thinkingOverlay';
                                overlay.className = 'thinking-overlay';
                                overlay.setAttribute('aria-hidden', 'true');
                                overlay.innerHTML = '<div class="thinking-icon"><i class="fa-solid fa-brain" aria-hidden="true"></i></div><div class="thinking-text" id="thinkingText">Pensando...</div>';
                                document.body.appendChild(overlay);
                            }
                            return overlay;
                        }

                        function startThinking() {
                            if (__currentThinking && typeof __currentThinking.cleanup === 'function') {
                                try { __currentThinking.cleanup(); } catch (e) {}
                                __currentThinking = null;
                            }

                            __thinkingToken++;
                            const myToken = __thinkingToken;

                            const phrases = [
                                'Pensando',
                                'Analizando',
                                'Revisando fuentes',
                                'Formulando respuesta',
                                'Preparando',
                                'Comprobando',
                                'Sintetizando'
                            ];

                            const overlay = ensureThinkingOverlay();
                            const textEl = overlay.querySelector('#thinkingText');

                            overlay.classList.add('visible');
                            overlay.setAttribute('aria-hidden', 'false');

                            const dotIntervalMs = 420;
                            const changePhraseMs = 2200;
                            const changeEveryTicks = Math.max(1, Math.round(changePhraseMs / dotIntervalMs));

                            let currentPhrase = phrases[Math.floor(Math.random() * phrases.length)];
                            let dots = 0;
                            let tick = 0;
                            if (textEl) textEl.textContent = currentPhrase + '...';

                            const interval = setInterval(() => {
                                if (myToken !== __thinkingToken) return;
                                tick++;
                                dots = (dots + 1) % 4;
                                if (tick % changeEveryTicks === 0) {
                                    let next = currentPhrase;
                                    if (phrases.length > 1) {
                                        while (next === currentPhrase) {
                                            next = phrases[Math.floor(Math.random() * phrases.length)];
                                        }
                                    } else {
                                        next = phrases[0];
                                    }
                                    currentPhrase = next;
                                }
                                if (textEl) textEl.textContent = currentPhrase + (dots ? '.'.repeat(dots) : '');
                            }, dotIntervalMs);

                            const fallbackTimeout = setTimeout(() => {
                                try { cleanup(); } catch (e) {}
                            }, 900000);

                            function cleanup() {
                                try { clearInterval(interval); } catch (e) {}
                                try { clearTimeout(fallbackTimeout); } catch (e) {}
                                try { overlay.classList.remove('visible'); overlay.setAttribute('aria-hidden', 'true'); } catch (e) {}
                                if (__currentThinking && __currentThinking.token === myToken) __currentThinking = null;
                            }

                            __currentThinking = {
                                token: myToken,
                                cleanup,
                                interval,
                                fallbackTimeout
                            };

                            return __currentThinking;
                        }

                        function stopThinking(tokenObj) {
                            if (tokenObj && typeof tokenObj.cleanup === 'function') {
                                try { tokenObj.cleanup(); } catch (e) {}
                                if (__currentThinking && __currentThinking.token === tokenObj.token) __currentThinking = null;
                                return;
                            }
                            if (__currentThinking && typeof __currentThinking.cleanup === 'function') {
                                try { __currentThinking.cleanup(); } catch (e) {}
                                __currentThinking = null;
                                return;
                            }
                            const overlay = document.getElementById('thinkingOverlay');
                            if (overlay) {
                                try { overlay.classList.remove('visible'); overlay.setAttribute('aria-hidden', 'true'); } catch (e) {}
                            }
                            __currentThinking = null;
                        }

                        function positionChatInput() {
                            const centerCol = q('#colCenter');
                            const chatInner = q('#chatInputInner');
                            const footer = q('#nexusFooter');
                            if (!centerCol || !chatInner || !footer) return;

                            const rect = centerCol.getBoundingClientRect();
                            const footerH = Math.ceil(footer.getBoundingClientRect().height || 0);
                            const gap = 8;

                            const vw = window.innerWidth || document.documentElement.clientWidth;
                            if (vw <= 991) {
                                chatInner.style.left = '8px';
                                chatInner.style.width = (vw - 16) + 'px';
                                chatInner.style.maxWidth = (vw - 16) + 'px';
                            } else {
                                const left = Math.max(8, rect.left + 8);
                                const width = Math.max(300, rect.width - 16);
                                chatInner.style.left = left + 'px';
                                chatInner.style.width = width + 'px';
                                chatInner.style.maxWidth = width + 'px';
                            }
                            chatInner.style.position = 'fixed';
                            chatInner.style.bottom = (footerH + gap) + 'px';
                            chatInner.style.zIndex = 1300;

                            const computedH = chatInner.getBoundingClientRect().height || 72;
                            document.documentElement.style.setProperty('--chat-input-height', computedH + 'px');
                            qa('.result-area').forEach(el => el.style.paddingBottom = (computedH + 28) + 'px');
                        }

                        function stabilizePositionDuringTransition(timeout = 700, threshold = 2, stableFrames = 3) {
                            const chatInner = q('#chatInputInner');
                            const centerCol = q('#colCenter');
                            if (!chatInner || !centerCol) return Promise.resolve(false);

                            let lastLeft = null, lastWidth = null, stableCount = 0;
                            const start = performance.now();

                            return new Promise(resolve => {
                                function step() {
                                    const rect = centerCol.getBoundingClientRect();
                                    const vw = window.innerWidth || document.documentElement.clientWidth;
                                    let desiredLeft, desiredWidth;
                                    if (vw <= 991) {
                                        desiredLeft = 8;
                                        desiredWidth = Math.max(300, vw - 16);
                                    } else {
                                        desiredLeft = Math.max(8, rect.left + 8);
                                        desiredWidth = Math.max(300, rect.width - 16);
                                    }

                                    if (lastLeft === null) { lastLeft = desiredLeft; lastWidth = desiredWidth; stableCount = 1; }
                                    else {
                                        const dl = Math.abs(desiredLeft - lastLeft);
                                        const dw = Math.abs(desiredWidth - lastWidth);
                                        if (dl <= threshold && dw <= threshold) stableCount++; else stableCount = 1;
                                        lastLeft = desiredLeft; lastWidth = desiredWidth;
                                    }

                                    chatInner.style.left = desiredLeft + 'px';
                                    chatInner.style.width = desiredWidth + 'px';
                                    chatInner.style.maxWidth = desiredWidth + 'px';
                                    positionChatInput();

                                    if (stableCount >= stableFrames) return resolve(true);
                                    if (performance.now() - start > timeout) return resolve(false);
                                    requestAnimationFrame(step);
                                }
                                requestAnimationFrame(step);
                            });
                        }

                        document.addEventListener('DOMContentLoaded', () => {
                            const textarea = q('#chatInput');
                            const chatInner = q('#chatInputInner');
                            const sendBtn = q('#sendChat');
                            const chatOutputEl = q('#chatOutput');
                            const studioAudioBtn = q('#studioAudio');if (!studioAudioBtn) return;
                            const studioVideoBtn = q('#studioVideo');if (!studioVideoBtn) return;


                                         const studioMindBtn = q('#studioMind');if (!studioMindBtn) return;

               studioMindBtn.addEventListener('click', async (ev) => {
                   ev.preventDefault();
                   const btn = studioMindBtn;
                   btn.disabled = true;
                   btn.classList.add('loading');
                   // Recupera caseCode desde el panel (o inyectado desde Razor)
                   const casePanel = q('#cfTopPanel');
                   const caseCode = casePanel ? casePanel.dataset.case : '@Model.CaseCode';
                                   // Mensaje que se enviará al controlador (puedes ajustarlo)
                 const message = textarea?.value?.trim();
                 // UI thinking
                 const thinking = startThinking();
                 setBtnLoading(true);
                 try {
                     await stabilizePositionDuringTransition(900);
                    const resp = await fetch('@Url.Action("ChatAjax", "Nexus")', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ caseCode: caseCode, message: message, origin: 'nexus-facturas' })
                    });
                    setBtnLoading(false);
                    stopThinking(thinking);
                    if (!resp.ok) throw new Error(resp.statusText || 'Error en la petición');
                    const data = await resp.json();
                    // Convierte la respuesta (markdown) a HTML y la escribe en el panel con la misma animación
                    const chatOutputEl = q('#chatOutput');
                    const html = (typeof marked !== 'undefined') ? marked.parse(data.response || '') : (data.response || '');
                    if (chatOutputEl) {
                        await typeWriteInto(chatOutputEl, html, 3);
                    }

                    // Limpia / enfoca textarea como en el flujo normal
                    const ta = q('#chatInput');
                    if (ta) {
                        ta.value = '';
                        try { autoResize(ta); } catch (e) {}
                        try { ta.focus({ preventScroll: true }); } catch (e) { ta.focus(); }
                    }
                } catch (err) {
                    console.error('studioMind error', err);
                    stopThinking();
                    setBtnLoading(false);
                    alert('Error al generar el resumen: ' + (err && err.message ? err.message : 'Error en la petición'));
                } finally {
                    btn.disabled = false;
                    btn.classList.remove('loading');
                    stopThinking();
                    positionChatInput();
                }
            });

                           studioVideoBtn.addEventListener('click', async (ev) => {
                               ev.preventDefault();
                               const btn = studioVideoBtn;
                               btn.disabled = true;
                               btn.classList.add('loading');
                               // Recupera caseCode desde el panel (o inyectado desde Razor)
                               const casePanel = q('#cfTopPanel');
                               const caseCode = casePanel ? casePanel.dataset.case : '@Model.CaseCode';
                                               // Mensaje que se enviará al controlador (puedes ajustarlo)
                             const message  = textarea?.value?.trim();
                             // UI thinking
                             const thinking = startThinking();
                             setBtnLoading(true);
                             try {
                                 await stabilizePositionDuringTransition(900);
                                const resp = await fetch('@Url.Action("ChatAjax", "Nexus")', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ caseCode: caseCode, message: message, origin: 'nexus-alerta' })
                                });
                                setBtnLoading(false);
                                stopThinking(thinking);
                                if (!resp.ok) throw new Error(resp.statusText || 'Error en la petición');
                                const data = await resp.json();
                                // Convierte la respuesta (markdown) a HTML y la escribe en el panel con la misma animación
                                const chatOutputEl = q('#chatOutput');
                                const html = (typeof marked !== 'undefined') ? marked.parse(data.response || '') : (data.response || '');
                                if (chatOutputEl) {
                                    await typeWriteInto(chatOutputEl, html, 3);
                                }

                                // Limpia / enfoca textarea como en el flujo normal
                                const ta = q('#chatInput');
                                if (ta) {
                                    ta.value = '';
                                    try { autoResize(ta); } catch (e) {}
                                    try { ta.focus({ preventScroll: true }); } catch (e) { ta.focus(); }
                                }
                            } catch (err) {
                                console.error('studioVideo error', err);
                                stopThinking();
                                setBtnLoading(false);
                                alert('Error al generar el resumen: ' + (err && err.message ? err.message : 'Error en la petición'));
                            } finally {
                                btn.disabled = false;
                                btn.classList.remove('loading');
                                stopThinking();
                                positionChatInput();
                            }
                        });



                studioAudioBtn.addEventListener('click', async (ev) => {
                    ev.preventDefault();
                    const btn = studioAudioBtn;
                    btn.disabled = true;
                    btn.classList.add('loading');
                    // Recupera caseCode desde el panel (o inyectado desde Razor)
                    const casePanel = q('#cfTopPanel');
                    const caseCode = casePanel ? casePanel.dataset.case : '@Model.CaseCode';
                                    // Mensaje que se enviará al controlador (puedes ajustarlo)
                  const message = textarea?.value?.trim();
                  // UI thinking
                  const thinking = startThinking();
                  setBtnLoading(true);
                  try {
                      await stabilizePositionDuringTransition(900);
                     const resp = await fetch('@Url.Action("ChatAjax", "Nexus")', {
                         method: 'POST',
                         headers: { 'Content-Type': 'application/json' },
                         body: JSON.stringify({ caseCode: caseCode, message: message, origin: 'nexus-contrato' })
                     });
                     setBtnLoading(false);
                     stopThinking(thinking);
                     if (!resp.ok) throw new Error(resp.statusText || 'Error en la petición');
                     const data = await resp.json();
                     // Convierte la respuesta (markdown) a HTML y la escribe en el panel con la misma animación
                     const chatOutputEl = q('#chatOutput');
                     const html = (typeof marked !== 'undefined') ? marked.parse(data.response || '') : (data.response || '');
                     if (chatOutputEl) {
                         await typeWriteInto(chatOutputEl, html, 3);
                     }

                     // Limpia / enfoca textarea como en el flujo normal
                     const ta = q('#chatInput');
                     if (ta) {
                         ta.value = '';
                         try { autoResize(ta); } catch (e) {}
                         try { ta.focus({ preventScroll: true }); } catch (e) { ta.focus(); }
                     }
                 } catch (err) {
                     console.error('studioAudio error', err);
                     stopThinking();
                     setBtnLoading(false);
                     alert('Error al generar el resumen: ' + (err && err.message ? err.message : 'Error en la petición'));
                 } finally {
                     btn.disabled = false;
                     btn.classList.remove('loading');
                     stopThinking();
                     positionChatInput();
                 }
             });

                            function autoResize(el) {
                                if (!el) return;
                                el.style.height = 'auto';
                                const max = 320;
                                const newH = Math.min(el.scrollHeight, max);
                                el.style.height = newH + 'px';
                                positionChatInput();
                            }
                            if (textarea) {
                                autoResize(textarea);
                                textarea.addEventListener('input', () => {
                                    stopThinking();
                                    setBtnLoading(false);
                                    autoResize(textarea);
                                });

                                textarea.addEventListener('focus', () => {
                                    if (chatInner) chatInner.classList.add('has-focus');
                                });
                                textarea.addEventListener('blur', () => {
                                    if (chatInner) chatInner.classList.remove('has-focus');
                                });

                                textarea.addEventListener('keydown', (e) => {
                                    if (e.key === 'Enter' && !e.shiftKey) {
                                        e.preventDefault();
                                        sendBtn.click();
                                    }
                                });
                            }

        async function typeWriteInto(el, html, speed = 3, dividerText = null) {
            if (!el) return;
            __typeToken++;
            const myToken = __typeToken;

            // Si ya hay respuestas previas, añadimos la "raya" separadora
            const existingResponses = el.querySelectorAll('.chat-response').length;
            if (existingResponses > 0) {
                const divider = document.createElement('div');
                divider.className = 'chat-divider';
                if (dividerText && dividerText.toString().trim() !== '') {
                    const span = document.createElement('span');
                    span.textContent = dividerText;
                    divider.appendChild(span);
                }
                el.appendChild(divider);
            }

            // Crear un contenedor por respuesta para NO tocar el contenido previo
            const container = document.createElement('div');
            container.className = 'chat-response';
            container.setAttribute('data-content', html);
            el.appendChild(container);

            const parentScroll = el.closest('.result-area') || el.parentElement;

            // --- SCROLL INICIAL UNA ÚNICA VEZ: llevar la vista al punto donde empezará a escribir
            try {
                if (parentScroll) {
                    // único salto inicial para que el cliente note el inicio de la respuesta
                    parentScroll.scrollTop = parentScroll.scrollHeight;
                }
            } catch (e) { /* ignore */ }

            // Ajuste de velocidad: effectiveDelay en ms entre pasos
            const effectiveDelay = Math.max(1, Math.round((speed) / 2)); // speed=6 -> ~3ms
            const chunk = Math.max(1, Math.round(6 / Math.max(1, effectiveDelay))); // cuantos caracteres avanzamos por tick

            let i = 0;
            return new Promise(resolve => {
                function step() {
                    // cancelado por otro tipeo
                    if (myToken !== __typeToken) return resolve();

                    // avanzar por "chunks" para que sea perceptiblemente más rápido
                    i = Math.min(html.length, i + chunk);

                    // Mantener la aproximación original: slice del HTML
                    container.innerHTML = html.slice(0, i);

                    // **NO** forzamos scroll mientras escribe ni al finalizar (solo el salto inicial ya hecho)
                    if (i < html.length) {
                        setTimeout(step, effectiveDelay);
                    } else {
                        resolve();
                    }
                }
                step();
            });
        }






                            function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

                            async function sendMessage() {
                                const text = textarea?.value?.trim();
                                if (!text) return;
                                let thinking = null;
                                try {
                                    setBtnLoading(true);
                                    thinking = startThinking();
                                    const minDelay = 700, maxDelay = 1600;
                                    const randomDelay = Math.floor(Math.random() * (maxDelay - minDelay + 1)) + minDelay;
                                    await sleep(randomDelay);

                                    await stabilizePositionDuringTransition(900);
                                    const resp = await fetch('@Url.Action("ChatAjax", "Nexus")', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ caseCode: '@Model.CaseCode', message: text,origin: 'chat-nexus' })
                                    });

                                    stopThinking(thinking);
                                    setBtnLoading(false);

                                    if (!resp.ok) throw new Error(resp.statusText);
                                    const data = await resp.json();

                                    const html = marked.parse(data.response || '');
                                    await typeWriteInto(chatOutputEl, html, 6);

                                    textarea.value = ''; autoResize(textarea);
                                    try { textarea.focus({ preventScroll: true }); } catch (e) { textarea.focus(); }
                                } catch (err) {
                                    console.error(err);
                                    stopThinking(thinking);
                                    setBtnLoading(false);
                                    alert('Error: ' + (err && err.message ? err.message : 'Error en la petición'));
                                } finally {
                                    positionChatInput();
                                }
                            }
                            if (sendBtn) sendBtn.addEventListener('click', sendMessage);

                            if (chatOutputEl) {
                                const content = chatOutputEl.getAttribute('data-content') || '';
                                if (content) chatOutputEl.innerHTML = content;
                            }

                            function bindTableRows() {
                                qa('.source-row').forEach(row => {
                                    const clone = row.cloneNode(true);
                                    row.parentNode.replaceChild(clone, row);
                                });
                                qa('.source-row').forEach(row => {
                                    row.addEventListener('click', (ev) => { ev.stopPropagation(); onSelectRow(row); });
                                    row.addEventListener('dblclick', (ev) => { ev.stopPropagation(); onSelectRow(row); const url = row.dataset.url; if (url) window.open(url, '_blank'); });
                                });
                                updateShownCount();
                            }

                            function updateShownCount() {
                                const visible = qa('#sourcesTable .source-row').length;
                                const shownEl = q('#shownCount');
                                const leftCountEl = q('#leftCount');
                                if (shownEl) shownEl.textContent = visible;
                                if (leftCountEl) leftCountEl.textContent = visible;
                            }

                            const sourcesWrapper = q('#sourcesWrapper');
                            const previewWrapper = q('#previewWrapper');
                            const previewContent = q('#previewContent');
                            const previewTitle = q('#previewTitle');
                            const btnBackToList = q('#btnBackToList');
                            const btnOpenInViewer = q('#btnOpenInViewer');
                            const btnDownloadPreview = q('#btnDownloadPreview');
                            const btnFlagPreview = q('#btnFlagPreview');
                            let currentPreview = { url: '', type: '' };

                                   async function onSelectRow(row) {
            // des-selecciona previos y selecciona este
            qa('.source-row.selected').forEach(r => r.classList.remove('selected'));
            row.classList.add('selected');

            const url = row.dataset.url;
            const type = (row.dataset.type || '').toLowerCase();
            const title = row.title || (row.querySelector('td:nth-child(2)')?.innerText) || 'Documento';
            if (previewTitle) previewTitle.textContent = title;

            // muestra el panel de preview (antes de medir)
            if (sourcesWrapper) sourcesWrapper.style.display = 'none';
            if (previewWrapper) previewWrapper.style.display = 'block';

            // Ajusta columnas (hacer grande la columna izquierda y reducir el centro)
            const leftCol = q('#colLeft'), centerCol = q('#colCenter'), rightCol = q('#colRight');
            if (leftCol && centerCol) {
                document.documentElement.classList.add('right-hidden');
                leftCol.style.flex = '0 0 70%';
                leftCol.style.maxWidth = '70%';
                leftCol.style.width = '70%';
                centerCol.style.flex = '0 0 30%';
                centerCol.style.maxWidth = '30%';
                centerCol.style.width = '30%';
                if (rightCol) rightCol.setAttribute('aria-hidden', 'true');
            }

            // Espera a que la transición/posicionamiento se estabilice antes de renderizar
            // Esto asegura que previewContent.clientWidth tiene el valor correcto
            await stabilizePositionDuringTransition(1000);

            // Guarda la info del preview y renderiza (await para usar dimensiones actualizadas)
            currentPreview = { url: url, type: type };
            await renderPreview(url, type);

            // Reposiciona el input chat ahora que todo está renderizado
            positionChatInput();
        }


                            function backToList() {
                                __pdfRenderToken++;
                                if (previewContent) previewContent.innerHTML = '';
                                currentPreview = { url: '', type: '' };
                                if (previewWrapper) previewWrapper.style.display = 'none';
                                if (sourcesWrapper) sourcesWrapper.style.display = 'block';
                                qa('.source-row.selected').forEach(r => r.classList.remove('selected'));
                                const leftCol = q('#colLeft'), centerCol = q('#colCenter'), rightCol = q('#colRight');
                                if (leftCol && centerCol) {
                                    document.documentElement.classList.remove('right-hidden');
                                    leftCol.style.width = ''; leftCol.style.flex = ''; leftCol.style.maxWidth = '';
                                    centerCol.style.width = ''; centerCol.style.flex = ''; centerCol.style.maxWidth = '';
                                    if (rightCol) { rightCol.style.display = ''; rightCol.style.width = ''; rightCol.style.flex = ''; rightCol.style.maxWidth = ''; rightCol.setAttribute('aria-hidden','false'); }
                                }
                                setTimeout(() => { stabilizePositionDuringTransition(900).then(() => positionChatInput()); }, 40);
                            }

                            if (btnBackToList) btnBackToList.addEventListener('click', backToList);
                            if (btnOpenInViewer) btnOpenInViewer.addEventListener('click', () => { if (!currentPreview.url) return alert('No hay documento en vista previa.'); window.open(currentPreview.url, '_blank'); });
                            if (btnDownloadPreview) btnDownloadPreview.addEventListener('click', () => { if (!currentPreview.url) return alert('No hay documento seleccionado.'); const a = document.createElement('a'); a.href = currentPreview.url; a.download = currentPreview.url.split('/').pop() || 'download'; document.body.appendChild(a); a.click(); a.remove(); });
                            if (btnFlagPreview) btnFlagPreview.addEventListener('click', () => { const selRow = q('.source-row.selected'); if (!selRow) return alert('Selecciona un documento primero.'); selRow.classList.toggle('marked'); });

                                    async function renderPreview(url, type) {
            // token para cancelar renders anteriores
            __pdfRenderToken++;
            const myToken = __pdfRenderToken;

            const previewContent = document.getElementById('previewContent');
            if (!previewContent) return;
            // asegurar estado limpio
            previewContent.innerHTML = '';
            previewContent.scrollTop = 0;
            // evitar scroll horizontal accidental
                    previewContent.style.overflow = 'auto';
        previewContent.style.webkitOverflowScrolling = 'touch';
            previewContent.style.boxSizing = 'border-box';

            if (!url) {
                previewContent.innerHTML = '<p class="text-muted">No se encontró la URL del documento.</p>';
                return;
            }

            // Si no es PDF, mostrar imagen (responsive)
            if (type !== 'pdf') {
                const img = document.createElement('img');
                img.src = url;
                img.className = 'img-fluid rounded preview-image';
                img.style.maxHeight = '100%';
                img.style.width = '100%';
                img.style.objectFit = 'contain';
                img.onerror = () => { previewContent.innerHTML = '<p class="text-danger">Error al cargar la imagen.</p>'; };
                previewContent.appendChild(img);
                img.onload = () => { stabilizePositionDuringTransition(400).then(() => positionChatInput()); };
                return;
            }

            // Barra de progreso
            const progressWrap = document.createElement('div');
            progressWrap.className = 'pdf-progress-wrap mb-2';
            progressWrap.innerHTML = `<div class="pdf-progress-label">Cargando PDF…</div>
                                      <div class="progress"><div class="progress-bar" role="progressbar" style="width:0%"></div></div>`;
            previewContent.appendChild(progressWrap);

            try {
                // Cargar PDF con pdf.js (pdfjsLib debe estar disponible)
                const loadingTask = pdfjsLib.getDocument(url);
                const pdf = await loadingTask.promise;

                // Si otro render se inició, abortar y liberar
                if (myToken !== __pdfRenderToken) { try { pdf.destroy?.(); } catch (e) {} return; }

                const total = pdf.numPages;
                const progressBar = progressWrap.querySelector('.progress-bar');

                // Contenedor de páginas (vertical y centrado)
                const pagesContainer = document.createElement('div');
                pagesContainer.className = 'pdf-pages-container';
                pagesContainer.style.display = 'flex';
                pagesContainer.style.flexDirection = 'column';
                pagesContainer.style.gap = '12px';
                pagesContainer.style.alignItems = 'center';
                previewContent.appendChild(pagesContainer);

                for (let p = 1; p <= total; p++) {
                    // abort si hay render nuevo
                    if (myToken !== __pdfRenderToken) { try { pdf.destroy?.(); } catch (e) {} return; }

                    // Page box: columna para canvas + caption
                    const pageBox = document.createElement('div');
                    pageBox.className = 'pdf-page-box mb-3';
                    pageBox.setAttribute('data-page', p);
                    pageBox.style.display = 'flex';
                    pageBox.style.flexDirection = 'column';    // importante: caption debajo
                    pageBox.style.justifyContent = 'center';
                    pageBox.style.alignItems = 'center';
                    pageBox.style.padding = '8px';
                    pageBox.style.boxSizing = 'border-box';
                    pageBox.style.width = '100%';

                    const loader = document.createElement('div');
                    loader.className = 'pdf-page-loader';
                    loader.innerText = `Cargando página ${p} de ${total}...`;
                    pageBox.appendChild(loader);
                    pagesContainer.appendChild(pageBox);

                    const page = await pdf.getPage(p);

                    // Calcula ancho disponible del previewContent (restando paddings)
                    const cs = getComputedStyle(previewContent);
                    const paddingX = (parseFloat(cs.paddingLeft || 0) || 0) + (parseFloat(cs.paddingRight || 0) || 0);
                    const availableWidth = Math.max(300, (previewContent.clientWidth || 800) - paddingX - 24);

                    // Viewport original sin escala
                    const unscaledViewport = page.getViewport({ scale: 1 });

                    // Escala CSS para que la página quepa en el contenedor
                    const scale = Math.max(0.5, (availableWidth) / unscaledViewport.width);

                    // viewport en CSS pixels (lo que mostraremos)
                    const cssViewport = page.getViewport({ scale });

                    // factor de dispositivo (Retina)
                    const outputScale = Math.max(1, window.devicePixelRatio || 1);

                    // viewport en píxeles reales para el canvas
                    const pixelViewport = page.getViewport({ scale: scale * outputScale });

                    // Crear canvas con dimensiones en píxeles reales
                    const canvas = document.createElement('canvas');
                    canvas.width = Math.floor(pixelViewport.width);
                    canvas.height = Math.floor(pixelViewport.height);

                    // Mostrar canvas con tamaño CSS y centrado
                    canvas.style.width = Math.floor(cssViewport.width) + 'px';
                    canvas.style.height = 'auto'; // permitir ajuste proporcional
                    canvas.style.display = 'block';
                    canvas.style.margin = '0 auto';
                    canvas.style.maxWidth = '100%';
                    canvas.className = 'pdf-page-canvas rounded';

                    const ctx = canvas.getContext('2d', { alpha: false });

                    // Verificar token antes de render
                    if (myToken !== __pdfRenderToken) { try { page.cleanup?.(); } catch (e) {} return; }

                    try {
                        // Render usando viewport en píxeles reales para conservar nitidez
                        await page.render({ canvasContext: ctx, viewport: pixelViewport }).promise;
                    } catch (errRender) {
                        console.error('Error renderizando página', p, errRender);
                        pageBox.innerHTML = `<div class="text-danger">Error al renderizar página ${p}</div>`;
                        continue;
                    }

                    // Reemplazar loader por canvas y caption (caption debajo, centrado)
                    pageBox.removeChild(loader);
                    pageBox.appendChild(canvas);

                    const caption = document.createElement('div');
                    caption.className = 'pdf-page-caption small text-muted mt-1';
                    caption.innerText = `Página ${p} / ${total}`;
                    caption.style.textAlign = 'center';
                    caption.style.width = '100%';
                    caption.style.marginTop = '8px';
                    pageBox.appendChild(caption);

                    // Actualiza progreso
                    const percent = Math.round((p / total) * 100);
                    if (progressBar) progressBar.style.width = percent + '%';

                    // pequeña pausa cooperativa para UI
                    await new Promise(res => setTimeout(res, 20));
                }

                // remover progress bar
                if (progressWrap && progressWrap.parentNode) progressWrap.parentNode.removeChild(progressWrap);

                // Después de renderizar, intentar estabilizar layout y reposicionar input chat
                if (previewContent) { stabilizePositionDuringTransition(500).then(() => positionChatInput()); }
            } catch (err) {
                console.error('Error al cargar PDF completo', err);
                previewContent.innerHTML = '<p class="text-danger">Error al cargar el PDF. Revisa CORS o la URL.</p>';
                stabilizePositionDuringTransition(400).then(() => positionChatInput());
            }
        }


                                const btnRefresh = q('#btnRefreshSources');
                                if (btnRefresh) btnRefresh.addEventListener('click', () => bindTableRows());
                                bindTableRows();

                                window.addEventListener('resize', () => { positionChatInput(); stabilizePositionDuringTransition(); });
                                const mo = new MutationObserver(() => { positionChatInput(); stabilizePositionDuringTransition(); });
                                mo.observe(document.body, { childList: true, subtree: true });

                                setTimeout(() => { positionChatInput(); stabilizePositionDuringTransition(); }, 160);
                                });

                        (function () {
                            let __panelsTO = null;
                            function detectHeaderFooter() {
                                const headerSelectors = ['header', '.navbar', '.topbar', '.site-header', '.main-header'];
                                const footerSelectors = ['#nexusFooter', 'footer.site-footer', '.site-footer', '.nexus-notice'];
                                function firstMatch(list) { for (const s of list) { const el = document.querySelector(s); if (el) return el; } return null; }
                                const explicitFooter = firstMatch(footerSelectors);
                                const explicitHeader = firstMatch(headerSelectors);

                                const fixedBottomCandidates = [];
                                Array.from(document.body.children).forEach(el => {
                                    try {
                                        const cs = getComputedStyle(el);
                                        if ((cs.position === 'fixed' || cs.position === 'sticky') && cs.display !== 'none') {
                                            const rect = el.getBoundingClientRect();
                                            if (rect.bottom >= window.innerHeight - 2 || rect.bottom >= window.innerHeight - 80) {
                                                fixedBottomCandidates.push(el);
                                            }
                                        }
                                    } catch (e) { }
                                });

                                return { header: explicitHeader, footer: explicitFooter, fixedBottoms: fixedBottomCandidates };
                            }

                            function applyHeights() {
                                try {
                                    const det = detectHeaderFooter();
                                    const headerH = det.header ? Math.ceil(det.header.getBoundingClientRect().height) : 0;

                                    let footerH = 0;
                                    if (det.footer) { try { footerH = Math.max(footerH, Math.ceil(det.footer.getBoundingClientRect().height)); } catch (e) {} }
                                    det.fixedBottoms.forEach(e => { try { footerH = Math.max(footerH, Math.ceil(e.getBoundingClientRect().height)); } catch (e) {} });

                                    const nexus = document.getElementById('nexusFooter');
                                    if (nexus) {
                                        nexus.style.position = 'fixed';
                                        nexus.style.left = '0';
                                        nexus.style.right = '0';
                                        nexus.style.bottom = '0';
                                        nexus.style.zIndex = '1200';
                                        nexus.style.width = '100%';
                                        try { footerH = Math.max(footerH, Math.ceil(nexus.getBoundingClientRect().height)); } catch (e) {}
                                    }

                                    document.documentElement.style.setProperty('--footer-height', (footerH || 72) + 'px');
                                    document.body.style.paddingBottom = (footerH || 72) + 'px';
                                    const extra = 6;
                                    const available = Math.max(180, Math.floor(window.innerHeight - headerH - (footerH || 72) - extra));
                                    const container = document.querySelector('.app-container');
                                    if (container) container.style.minHeight = (window.innerHeight - headerH - (footerH || 72)) + 'px';
                                    qa('.col-lg-3, .col-lg-6, .col-lg-3').forEach(col => {
                                        col.style.display = 'flex';
                                        col.style.flexDirection = 'column';
                                        col.style.paddingBottom = '0';
                                        col.style.marginBottom = '0';
                                        col.style.minHeight = '0';
                                    });
                                    qa('.card.card-panel-left, .card.card-panel-center, .card.card-panel-right').forEach(card => {
                                        card.style.display = 'flex';
                                        card.style.flexDirection = 'column';
                                        card.style.height = available + 'px';
                                        card.style.maxHeight = available + 'px';
                                        card.style.minHeight = '0';
                                        card.style.marginBottom = '0';
                                    });
                                    qa('.card.card-panel-center, .card.card-panel-right').forEach(card => {
                                        const body = card.querySelector('.card-body.panel-body');
                                        if (body) {
                                            body.style.flex = '1 1 auto';
                                            body.style.minHeight = '0';
                                            const result = body.querySelector('.result-area');
                                            if (result) {
                                                result.style.flex = '1 1 auto';
                                                result.style.minHeight = '0';
                                                result.style.overflowY = 'auto';
                                            }
                                        }
                                    });

                                    qa('.card.card-panel-left .card-body.panel-body').forEach(body => {
                                        body.style.flex = '1 1 auto';
                                        body.style.minHeight = '0';
                                        body.style.overflow = 'hidden';
                                    });

                                    const previewContent = document.querySelector('#previewContent');
                                    if (previewContent) {
                                        const panel = previewContent.closest('.panel-height') || previewContent.closest('.card-body.panel-body');
                                        if (panel) {
                                            const panelRect = panel.getBoundingClientRect();
                                            const previewHeader = panel.querySelector('.d-flex.align-items-center') || panel.querySelector('.card-header');
                                            const headerInnerH = previewHeader ? Math.ceil(previewHeader.getBoundingClientRect().height) : 48;
                                            const footerCompact = panel.querySelector('.mt-2.d-flex') || panel.querySelector('.card-footer');
                                            const footerInnerH = footerCompact ? Math.ceil(footerCompact.getBoundingClientRect().height) : 40;
                                            const innerAvailable = Math.max(120, Math.floor(panelRect.height - headerInnerH - footerInnerH - 16));
                                            previewContent.style.height = innerAvailable + 'px';
                                            previewContent.style.maxHeight = innerAvailable + 'px';
                                            previewContent.style.minHeight = '0';
                                            previewContent.style.overflowY = 'auto';
                                            previewContent.style.boxSizing = 'border-box';
                                        }
                                    }

                                    qa('.pdf-pages-container, .pdf-page-box').forEach(el => { el.style.overflow = 'visible'; });

                                    // RIGHT PANEL: ensure studio panel children scroll independently
                                    qa('.card.card-panel-right').forEach(card => {
                                        const body = card.querySelector('.card-body.panel-body');
                                        if (!body) return;
                                        const studioInner = body.querySelector('.studio-panel-body');
                                        if (!studioInner) return;
                                        // studioInner already flex column in CSS; ensure children have correct flex/scroll
                                        const grid = studioInner.querySelector('.studio-grid');
                                        if (grid) {
                                            grid.style.flex = '1 1 auto';
                                            grid.style.minHeight = '0';
                                            grid.style.overflowY = 'auto';
                                            grid.style.paddingRight = '8px';
                                        }
                                        const feedback = studioInner.querySelector('#cfTopPanel');
                                        if (feedback) {
                                            // keep feedback visible at bottom; don't let it stretch
                                            feedback.style.flex = '0 0 auto';
                                            feedback.style.marginTop = '12px';
                                        }
                                    });

                                    document.documentElement.style.setProperty('--available-panel-height', available + 'px');
                                } catch (err) {
                                    console.warn('applyHeights error', err);
                                }
                            }

                            function scheduleApply() {
                                clearTimeout(__panelsTO);
                                __panelsTO = setTimeout(applyHeights, 80);
                            }

                            window.addEventListener('load', scheduleApply);
                            window.addEventListener('resize', scheduleApply);
                            const mo = new MutationObserver(() => scheduleApply());
                            mo.observe(document.body, { childList: true, subtree: true });

                            window.__setPanelsHeight = applyHeights;
                            scheduleApply();
                        })();
                    })();
                </script>

                <script>
            (function () {
                const panel = document.getElementById('cfTopPanel');
                if (!panel) return;
                const caseCode = panel.dataset.case || '';
                const buttons = Array.from(panel.querySelectorAll('.cf-toggle-btn'));
                const commentEl = document.getElementById('cfComment');
                const sendBtn = document.getElementById('cfSend');
                const cancelBtn = document.getElementById('cfCancel');
                const statusEl = document.getElementById('cfStatus');

                let state = { helped: null, comment: '' };

                function setStatus(text, tone) {
                    statusEl.textContent = text || '';
                    statusEl.className = 'small ' + (tone === 'ok' ? 'text-success' : tone === 'err' ? 'text-danger' : 'text-muted');
                }

                function clearSelection() {
                    state.helped = null;
                    buttons.forEach(b => { b.classList.remove('active'); b.setAttribute('aria-pressed', 'false'); });
                }

                // toggle buttons estilo "tile"
                buttons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const val = btn.dataset.value === 'true';
                        // si hizo click en mismo valor, toggle off
                        if (state.helped === val) {
                            clearSelection();
                        } else {
                            state.helped = val;
                            buttons.forEach(b => {
                                const isActive = (b === btn);
                                b.classList.toggle('active', isActive);
                                b.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                            });
                        }
                        setStatus('', null);
                    });
                });
                sendBtn.addEventListener('click', async () => {
                    state.comment = (commentEl && commentEl.value || '').trim();
                    if (state.helped === null) {
                        setStatus('Selecciona Sí/No o escribe un comentario antes de enviar.', 'err');
                        return;
                    }
                    sendBtn.disabled = true;
                    buttons.forEach(b => b.disabled = true);
                    setStatus('Enviando reseña…', 'muted');

                    const payload = { caseCode: caseCode, helped: state.helped, comment: state.comment };

                    try {
                        const resp = await fetch('@Url.Action("SubmitFeedback", "Nexus")', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!resp.ok) throw new Error('Status ' + resp.status);
                        const data = await resp.json();
                        if (data && data.success) {
                            setStatus('Gracias — reseña enviada.', 'ok');
                            sendBtn.classList.remove('btn-primary');
                            sendBtn.classList.add('btn-success');
                            sendBtn.textContent = 'Enviado';
                        } else {
                            throw new Error((data && data.message) ? data.message : 'No fue posible guardar la reseña.');
                        }
                    } catch (err) {
                        console.error('Feedback error', err);
                        try {
                            const key = 'nexus_feedback_offline_' + (caseCode || 'unknown') + '_' + new Date().getTime();
                            localStorage.setItem(key, JSON.stringify(Object.assign({}, payload, { ts: new Date().toISOString() })));
                            setStatus('No se pudo enviar ahora. Guardado localmente.', 'err');
                        } catch (e) {
                            setStatus('Error al enviar reseña. Intenta nuevamente más tarde.', 'err');
                        }
                        sendBtn.disabled = false;
                        buttons.forEach(b => b.disabled = false);
                        cancelBtn.disabled = false;
                        return;
                    }

                    sendBtn.disabled = true;
                    buttons.forEach(b => b.disabled = true);
                    cancelBtn.disabled = true;
                });
                buttons.forEach(b => {
                    b.addEventListener('keydown', (ev) => {
                        if (ev.key === 'Enter' || ev.key === ' ') {
                            ev.preventDefault();
                            b.click();
                        }
                    });
                });
            })();
            </script>


    <script>
                (function () {
          'use strict';

          // Si existe window.nexusConfig lo usamos, si no, usamos rutas por defecto (Razor ya las inyectó arriba).
          const cfg = window.nexusConfig || {};
          const notesGetUrl = cfg.notesGetUrl || '@Url.Action("GetNotes", "Nexus")';
          const notesAddUrl = cfg.notesAddUrl || '@Url.Action("AddNote", "Nexus")';
          const notesDeleteUrl = cfg.notesDeleteUrl || '@Url.Action("DeleteNote", "Nexus")';

          function getCaseCode() {
            const panel = document.getElementById('cfTopPanel');
            if (panel && panel.dataset && panel.dataset.case) return panel.dataset.case;
            return (window.nexusConfig && window.nexusConfig.caseCode) || '';
          }

          document.addEventListener('DOMContentLoaded', () => {
            console.debug('[NexusNotes] DOMContentLoaded - inicializando');

            // refs DOM
            let notesListEl = document.getElementById('notesList');
            let notesEditor = document.getElementById('notesEditor');
            let notesCancel = document.getElementById('notesCancel');
            let notesSave = document.getElementById('notesSave');
            let btnAddNote = document.getElementById('btnAddNote');
            let btnRefreshNotes = document.getElementById('btnRefreshNotes');
            let noteTitle = document.getElementById('noteTitle');
            let noteDetail = document.getElementById('noteDetail');
            let notesStatus = document.getElementById('notesStatus');
            let notesEditorTitle = document.getElementById('notesEditorTitle');

            function refreshRefs() {
              notesListEl = document.getElementById('notesList') || notesListEl;
              notesEditor = document.getElementById('notesEditor') || notesEditor;
              notesCancel = document.getElementById('notesCancel') || notesCancel;
              notesSave = document.getElementById('notesSave') || notesSave;
              noteTitle = document.getElementById('noteTitle') || noteTitle;
              noteDetail = document.getElementById('noteDetail') || noteDetail;
              notesStatus = document.getElementById('notesStatus') || notesStatus;
              notesEditorTitle = document.getElementById('notesEditorTitle') || notesEditorTitle;
            }

            // --- Fetch helpers ---
            async function getJson(url) {
              const resp = await fetch(url, { method: 'GET', headers: { 'Accept': 'application/json' } });
              if (!resp.ok) {
                const txt = await resp.text().catch(() => resp.statusText || 'Error GET');
                throw new Error(txt || 'Error GET');
              }
              return resp.json();
            }
            async function postJson(url, payload) {
              const resp = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });
              if (!resp.ok) {
                const txt = await resp.text().catch(() => resp.statusText || 'Error POST');
                throw new Error(txt || ('Error POST: ' + txt));
              }
              return resp.json();
            }

            function showStatus(text, isError) {
              if (!notesStatus) return;
              notesStatus.textContent = text || '';
              notesStatus.className = isError ? 'small text-danger' : 'small text-muted';
            }

            // --- Crear item de lista ---
            function createNoteItem(note) {
              const li = document.createElement('div');
              li.className = 'list-group-item d-flex justify-content-between align-items-start';
              li.dataset.noteId = note.id || '';

              const left = document.createElement('div');
              left.className = 'me-2 w-100';

              const h = document.createElement('div');
              h.className = 'fw-semibold text-truncate';
              h.textContent = note.title || '(Sin título)';

              const detailEl = document.createElement('div');
              detailEl.className = 'small text-muted note-detail';
              detailEl.textContent = note.detail || '';

              const meta = document.createElement('div');
              meta.className = 'small text-muted mt-1';
              const d = note.createdAt ? new Date(note.createdAt) : new Date();
              meta.textContent = `${d.toLocaleString()}${note.createdBy ? ' · ' + note.createdBy : ''}`;

              left.appendChild(h);
              left.appendChild(detailEl);
              left.appendChild(meta);

              const actions = document.createElement('div');
              actions.className = 'd-flex gap-1 ms-2 align-items-start';

              const btnEdit = document.createElement('button');
              btnEdit.type = 'button';
              btnEdit.className = 'btn btn-sm btn-light';
              btnEdit.title = 'Editar';
              btnEdit.innerHTML = '<i class="fa fa-pen"></i>';
              btnEdit.addEventListener('click', (e) => {
                e.stopPropagation();
                openEditor('edit', note);
              });

              const btnDel = document.createElement('button');
              btnDel.type = 'button';
              btnDel.className = 'btn btn-sm btn-outline-danger';
              btnDel.title = 'Eliminar';
              btnDel.innerHTML = '<i class="fa fa-trash"></i>';
              btnDel.addEventListener('click', async (e) => {
                e.stopPropagation();
                if (!confirm('¿Eliminar nota?')) return;
                li.remove();
                try {
                  const result = await deleteNote(note.id);
                  if (!result || !result.success) throw new Error(result?.error || 'Error al eliminar');
                  showStatus('Nota eliminada');
                } catch (err) {
                  console.error('delete note err', err);
                  showStatus('No se pudo eliminar la nota', true);
                  await loadNotes();
                }
              });

              actions.appendChild(btnEdit);
              actions.appendChild(btnDel);

              li.appendChild(left);
              li.appendChild(actions);

              li.addEventListener('click', () => {
                const expanded = li.classList.toggle('expanded');
                detailEl.style.display = expanded ? 'block' : (note.detail && note.detail.length > 120 ? 'none' : 'block');
              });

              if (note.detail && note.detail.length > 120) detailEl.style.display = 'none';

              return li;
            }

            // --- API calls ---
            async function loadNotes() {
              refreshRefs();
              if (!notesListEl) return;
              const caseCode = getCaseCode();
              notesListEl.innerHTML = '<div class="text-muted small text-center py-3">Cargando notas...</div>';
              try {
                const url = notesGetUrl + '?caseCode=' + encodeURIComponent(caseCode);
                const data = await getJson(url);
                const notes = Array.isArray(data) ? data : (data.items || []);
                notesListEl.innerHTML = '';
                if (!notes || notes.length === 0) {
                  notesListEl.innerHTML = '<div class="text-muted small text-center py-3">No hay notas para este caso.</div>';
                  showStatus('');
                  return;
                }
                notes.forEach(n => {
                  const item = createNoteItem(n);
                  notesListEl.appendChild(item);
                });
                showStatus('');
              } catch (err) {
                console.error('loadNotes err', err);
                notesListEl.innerHTML = '<div class="text-danger small text-center py-3">Error al cargar notas.</div>';
                showStatus('Error al cargar notas', true);
              }
            }

            async function saveNote(payload) {
              return postJson(notesAddUrl, payload);
            }

            async function deleteNote(id) {
              return postJson(notesDeleteUrl, { id });
            }

            // --- Editor UI ---
            function openEditor(mode = 'new', note = null) {
              refreshRefs();
              if (!notesEditor) return;
              notesEditor.style.display = 'block';
              notesEditor.setAttribute('aria-hidden', 'false');
              if (notesEditorTitle) notesEditorTitle.textContent = mode === 'edit' ? 'Editar nota' : 'Nueva nota';
              if (noteTitle) noteTitle.value = note?.title || '';
              if (noteDetail) noteDetail.value = note?.detail || '';
              if (notesSave) notesSave.dataset.editingId = note?.id ? String(note.id) : '';
              setTimeout(() => noteTitle && noteTitle.focus(), 80);
            }

            function closeEditor() {
              refreshRefs();
              if (!notesEditor) return;
              notesEditor.style.display = 'none';
              notesEditor.setAttribute('aria-hidden', 'true');
              if (noteTitle) noteTitle.value = '';
              if (noteDetail) noteDetail.value = '';
              if (notesSave) delete notesSave.dataset.editingId;
            }

            // --- Guardar: handler robusto ---
            async function handleNotesSaveClick(e) {
              try { e && e.preventDefault && e.preventDefault(); } catch (err) {}
              refreshRefs();
              const title = (noteTitle && noteTitle.value || '').trim();
              const detail = (noteDetail && noteDetail.value || '').trim();
              if (!title && !detail) { if (noteTitle) noteTitle.focus(); return; }
              const editingId = parseInt(notesSave?.dataset?.editingId || '0', 10) || 0;
              const payload = { id: editingId, caseCode: getCaseCode(), title, detail };

              try {
                showStatus('Guardando…');
                const result = await saveNote(payload);
                if (!result || !result.success) throw new Error(result?.error || 'Error al guardar');
                await loadNotes();
                showStatus('Nota guardada');
                closeEditor();
              } catch (err) {
                console.error('save note err', err);
                showStatus('No se pudo guardar la nota: ' + (err.message || ''), true);
              }
            }

            // Attach directo si existe, sino delegation + observer
            function attachSaveHandlerDirect() {
              refreshRefs();
              if (!notesSave) return false;
              try {
                if (!notesSave.getAttribute('type') || notesSave.getAttribute('type') !== 'button') {
                  notesSave.setAttribute('type', 'button');
                }
              } catch (err) {}
              notesSave.removeEventListener('click', handleNotesSaveClick);
              notesSave.addEventListener('click', handleNotesSaveClick);
              console.debug('[NexusNotes] handler directo adjuntado a #notesSave');
              return true;
            }

            if (!attachSaveHandlerDirect()) {
              document.addEventListener('click', function delegatedClick(e) {
                const btn = e.target && e.target.closest ? e.target.closest('#notesSave') : null;
                if (!btn) return;
                handleNotesSaveClick.call(btn, e);
              }, true);

              const mo = new MutationObserver((mutations, observer) => {
                if (attachSaveHandlerDirect()) observer.disconnect();
              });
              mo.observe(document.body, { childList: true, subtree: true });
              console.debug('[NexusNotes] usando delegation + observer para #notesSave');
            }

            // Otros bindings
            if (btnAddNote) btnAddNote.addEventListener('click', (e) => { e.preventDefault(); openEditor('new'); });
            if (btnRefreshNotes) btnRefreshNotes.addEventListener('click', (e) => { e.preventDefault(); loadNotes(); });
            if (notesCancel) notesCancel.addEventListener('click', (e) => { e.preventDefault(); closeEditor(); });

            // carga inicial
            setTimeout(() => loadNotes(), 50);

            // Exponer API mínima
            window.NexusNotes = { loadNotes, openEditor, closeEditor };
          }); // DOMContentLoaded
        })();

    </script>
    <script>

        (function() {
            const previewContent = document.getElementById('previewContent');
            const zoomInBtn      = document.getElementById('btnZoomIn');
            const zoomOutBtn     = document.getElementById('btnZoomOut');
            const zoomResetBtn   = document.getElementById('btnZoomReset');
            const zoomLabel      = document.getElementById('zoomLabel');

            if (!previewContent) return;

            // Constantes
            const MIN_SCALE = 0.2;
            const MAX_SCALE = 4.0;
            const STEP      = 0.1;
            let currentScale = 1.0;

            // helpers
            function findPrimary() {
                const wrapper = previewContent.querySelector('.preview-zoom-wrapper');
                if (wrapper) return { el: wrapper.firstElementChild, isWrapper: true, wrapper };
                const img = previewContent.querySelector('img.preview-image, img');
                if (img) return { el: img, isImage: true };
                const frame = previewContent.querySelector('iframe, embed, object');
                if (frame) return { el: frame, isFrame: true };
                return { el: previewContent.firstElementChild || previewContent, isWrapper: false };
            }

            function ensureWrapperIfNeeded() {
                const first = previewContent.firstElementChild;
                if (!first) return null;

                // Si ya está envuelto, retornamos el wrapper
                if (first.classList && first.classList.contains('preview-zoom-wrapper')) {
                    return first;
                }

                // Crear wrapper y mover el contenido dentro
                const wrapper = document.createElement('div');
                wrapper.className = 'preview-zoom-wrapper is-grab';
                // permitimos scroll/pan dentro del wrapper
                wrapper.style.overflow = 'auto';
                wrapper.style.width = '100%';
                wrapper.style.boxSizing = 'border-box';
                wrapper.style.touchAction = 'none';

                // mover hijos dentro del wrapper (manteniendo el orden)
                while (previewContent.firstChild) {
                    wrapper.appendChild(previewContent.firstChild);
                }
                previewContent.appendChild(wrapper);

                // keep consistent defaults for images
                const img = wrapper.querySelector('img');
                if (img) {
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    img.style.maxWidth = '100%';
                    img.style.display = 'block';
                    img.style.transformOrigin = 'top left';
                }

                return wrapper;
            }

            function updateZoomLabel() {
                if (zoomLabel) zoomLabel.textContent = Math.round(currentScale * 100) + '%';
            }

            // Aplicar escala (mantiene comportamiento previo para frames/otros y mejora imágenes)
            function applyScale(scale) {
                currentScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale));
                updateZoomLabel();

                const primary = findPrimary();
                if (!primary || !primary.el) return;

                // --- Imagenes: aplicamos transform scale y ajustamos wrapper para permitir panning ---


        // --- Imágenes: escalamos cambiando el width (no transform) para que el layout genere scroll natural ---
        if (primary.isImage) {
            let img = primary.el;
            // Asegurar wrapper
            let wrapper = img && img.parentElement && img.parentElement.classList && img.parentElement.classList.contains('preview-zoom-wrapper')
                ? img.parentElement
                : ensureWrapperIfNeeded();

            if (!img || !wrapper) return;

            // Guardar medidas y scroll previos (para preservar posición)
            const prevScrollLeft = wrapper.scrollLeft || 0;
            const prevScrollTop = wrapper.scrollTop || 0;
            const prevScrollWidth = wrapper.scrollWidth || 1;
            const prevScrollHeight = wrapper.scrollHeight || 1;
            const visibleW = wrapper.clientWidth || previewContent.clientWidth || 1;
            const visibleH = wrapper.clientHeight || previewContent.clientHeight || 1;

            // Asegurarnos estado base (sin transform) para medir correctamente
            img.style.transition = 'none';
            img.style.transform = 'none';
            img.style.maxWidth = '100%';
            img.style.height = 'auto';
            img.style.display = 'block';
            img.style.boxSizing = 'border-box';

            // Forzar reflow y obtener tamaño base (ancho/alto visibles ahora)
            const baseRect = img.getBoundingClientRect();
            const baseW = Math.max(1, Math.round(baseRect.width));
            const baseH = Math.max(1, Math.round(baseRect.height));

            // Si volvemos a scale = 1, restauramos comportamiento responsive
            if (currentScale === 1) {
                img.style.width = '';          // vuelve a responsive (max-width:100% toma efecto)
                img.style.maxWidth = '100%';
                img.style.height = 'auto';
                wrapper.style.width = '';
                wrapper.style.height = '';
                wrapper.style.overflow = '';   // hereda de CSS/previewContent
                // Restaurar scroll proporcionalmente (si acaso)
                try {
                    const prevMaxX = Math.max(0, prevScrollWidth - visibleW);
                    const newMaxX  = Math.max(0, wrapper.scrollWidth - visibleW);
                    const ratioX = prevMaxX > 0 ? (prevScrollLeft / prevMaxX) : 0;
                    wrapper.scrollLeft = Math.round(ratioX * newMaxX);

                    const prevMaxY = Math.max(0, prevScrollHeight - visibleH);
                    const newMaxY  = Math.max(0, wrapper.scrollHeight - visibleH);
                    const ratioY = prevMaxY > 0 ? (prevScrollTop / prevMaxY) : 0;
                    wrapper.scrollTop = Math.round(ratioY * newMaxY);
                } catch (e) { /* ignore */ }
                return;
            }

            // Calcular nuevo ancho/alto basado en la vista actual (esto evita el salto)
            const newW = Math.max(40, Math.round(baseW * currentScale));
            const newH = Math.max(40, Math.round(baseH * currentScale));

            // Aplicar ancho en píxeles (esto cambia layout y genera scroll natural)
            img.style.width = newW + 'px';
            img.style.maxWidth = 'none';
            img.style.height = 'auto';

            // Asegurar que el wrapper sea lo suficientemente grande para scrollear
            wrapper.style.width = newW + 'px';
            // No fijamos wrapper.height a newH obligatoriamente: permitir que el flujo determine altura,
            // pero si quieres forzar el scroll vertical, utiliza la línea siguiente (opcional)
            wrapper.style.height = newH + 'px';
            wrapper.style.overflow = 'auto';
            wrapper.style.boxSizing = 'border-box';

            // Restaurar scroll proporcional al nuevo tamaño (mantiene el punto de vista)
            try {
                const prevMaxX = Math.max(0, prevScrollWidth - visibleW);
                const newMaxX  = Math.max(0, wrapper.scrollWidth - visibleW);
                const ratioX = prevMaxX > 0 ? (prevScrollLeft / prevMaxX) : 0;
                wrapper.scrollLeft = Math.round(ratioX * newMaxX);

                const prevMaxY = Math.max(0, prevScrollHeight - visibleH);
                const newMaxY  = Math.max(0, wrapper.scrollHeight - visibleH);
                const ratioY = prevMaxY > 0 ? (prevScrollTop / prevMaxY) : 0;
                wrapper.scrollTop = Math.round(ratioY * newMaxY);
            } catch (e) { /* ignore */ }

            return;
        }


                // --- Iframes / objetos: mantén la lógica previa (escalado del wrapper) ---
                if (primary.isFrame || primary.isWrapper) {
                    let wrapper = previewContent.querySelector('.preview-zoom-wrapper');
                    if (!wrapper) wrapper = ensureWrapperIfNeeded();
                    if (!wrapper) return;

                    // Para iframes/embeds, escalamos el wrapper (no usar transform en el iframe)
                    wrapper.style.width  = (currentScale * 100) + '%';
                    wrapper.style.height = 'auto';

                    const inner = wrapper.firstElementChild;
                    if (inner && (inner.tagName === 'IFRAME' || inner.tagName === 'EMBED' || inner.tagName === 'OBJECT')) {
                        inner.style.width  = '100%';
                        inner.style.height = '100%';
                        inner.style.transform = 'none';
                    } else if (inner) {
                        // si el inner es contenido HTML, aplicamos transform para que escale proporcionalmente
                        inner.style.transform      = `scale(${currentScale})`;
                        inner.style.transformOrigin = 'top left';
                        const rect = inner.getBoundingClientRect();
                        wrapper.style.width  = (rect.width * currentScale) + 'px';
                        wrapper.style.height = (rect.height * currentScale) + 'px';
                    }
                    return;
                }

                // --- Fallback: si no encaja, intentamos escalar wrapper si existe ---
                let wrapper = previewContent.querySelector('.preview-zoom-wrapper');
                if (!wrapper) wrapper = ensureWrapperIfNeeded();
                if (!wrapper) return;
                wrapper.style.width  = (currentScale * 100) + '%';
                wrapper.style.height = 'auto';
            }

            // Acciones de zoom
            function zoomIn()    { applyScale(currentScale + STEP); }
            function zoomOut()   { applyScale(currentScale - STEP); }
            function zoomReset() { applyScale(1.0); }

            // Handlers para rueda+Ctrl y teclas
            function wheelHandler(e) {
                if (!e.ctrlKey) return;
                e.preventDefault();
                (e.deltaY < 0) ? zoomIn() : zoomOut();
            }

            function keyHandler(e) {
                const tag = (document.activeElement && document.activeElement.tagName) || '';
                if (['INPUT','TEXTAREA','SELECT'].includes(tag)) return;
                if (e.key === '+' || e.key === '=') { e.preventDefault(); zoomIn(); }
                else if (e.key === '-') { e.preventDefault(); zoomOut(); }
                else if (e.key === '0') { e.preventDefault(); zoomReset(); }
            }

            // Panning (drag) — funciona con wrapper (overflow: auto)
                   let isDown = false, startX = 0, startY = 0, scrollLeft = 0, scrollTop = 0, panWrapper = null;

        function startPan(e) {
            const wrapper = previewContent.querySelector('.preview-zoom-wrapper');
            if (!wrapper) return;
            panWrapper = wrapper;
            isDown = true;
            previewContent.classList.add('is-dragging');
            wrapper.classList.remove('is-grab');
            wrapper.classList.add('is-grabbing');

            startX = (e.pageX || (e.touches && e.touches[0] && e.touches[0].pageX)) || 0;
            startY = (e.pageY || (e.touches && e.touches[0] && e.touches[0].pageY)) || 0;
            scrollLeft = panWrapper.scrollLeft;
            scrollTop  = panWrapper.scrollTop;

            e.preventDefault && e.preventDefault();
        }

                  function movePan(e) {
            if (!isDown || !panWrapper) return;
            const x = (e.pageX || (e.touches && e.touches[0] && e.touches[0].pageX)) || 0;
            const y = (e.pageY || (e.touches && e.touches[0] && e.touches[0].pageY)) || 0;
            panWrapper.scrollLeft = scrollLeft - (x - startX);
            panWrapper.scrollTop  = scrollTop  - (y - startY);
        }

        function endPan() {
            if (!isDown) return;
            isDown = false;
            const wrapper = panWrapper || previewContent.querySelector('.preview-zoom-wrapper');
            if (wrapper) {
                wrapper.classList.remove('is-grabbing');
                wrapper.classList.add('is-grab');
            }
            previewContent.classList.remove('is-dragging');
            panWrapper = null;
        }

            // Listeners
            if (zoomInBtn)    zoomInBtn.addEventListener('click', (e) => { e.preventDefault(); zoomIn(); });
            if (zoomOutBtn)   zoomOutBtn.addEventListener('click', (e) => { e.preventDefault(); zoomOut(); });
            if (zoomResetBtn) zoomResetBtn.addEventListener('click', (e) => { e.preventDefault(); zoomReset(); });

            previewContent.addEventListener('wheel', wheelHandler, { passive: false });
            window.addEventListener('keydown', keyHandler, false);

            // Mouse panning
            previewContent.addEventListener('mousedown', (e) => { if (e.button === 0) startPan(e); });
            previewContent.addEventListener('mousemove', movePan);
            window.addEventListener('mouseup', endPan);

            // Touch panning
            previewContent.addEventListener('touchstart', (e) => startPan(e), { passive: false });
            previewContent.addEventListener('touchmove',  (e) => movePan(e), { passive: false });
            previewContent.addEventListener('touchend',   endPan);

            // API pública (conservadora: si ya existe la dejamos)
            window.NexusPreviewZoom = window.NexusPreviewZoom || {};
            window.NexusPreviewZoom.setScale = (s) => applyScale(s);
            window.NexusPreviewZoom.zoomIn = zoomIn;
            window.NexusPreviewZoom.zoomOut = zoomOut;
            window.NexusPreviewZoom.reset = zoomReset;
            window.NexusPreviewZoom.getScale = () => currentScale;

            updateZoomLabel();
        })();
    </script>


}

@functions {
    public string RenderMarkdown(string markdown)
    {
        if (string.IsNullOrEmpty(markdown)) return string.Empty;
        var pipeline = new MarkdownPipelineBuilder().UseAdvancedExtensions().Build();
        return Markdig.Markdown.ToHtml(markdown, pipeline);
    }
}
